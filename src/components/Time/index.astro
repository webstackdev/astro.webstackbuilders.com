---
type Common = {
  format?: 'datetime' | 'relative' | 'duration'
  tense?: 'auto' | 'past' | 'future'
  precision?: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second'
  threshold?: string
  prefix?: string
  formatStyle?: 'long' | 'short' | 'narrow'
  timeZone?: string
  second?: 'numeric' | '2-digit'
  minute?: 'numeric' | '2-digit'
  hour?: 'numeric' | '2-digit'
  weekday?: 'short' | 'long' | 'narrow'
  day?: 'numeric' | '2-digit'
  month?: 'numeric' | '2-digit' | 'short' | 'long' | 'narrow'
  year?: 'numeric' | '2-digit'
  timeZoneName?: 'long' | 'short' | 'shortOffset' | 'longOffset' | 'shortGeneric' | 'longGeneric'
}

export interface Props extends Common {
  datetime?: Date | string
  now?: boolean
}

const {
  now,
  datetime,
  format = 'datetime',
  formatStyle,
  timeZone,
  timeZoneName,
  weekday,
  year,
  month,
  day,
  hour,
  minute,
  second,
  ...attrs
} = Astro.props as Props
const resolvedDatetime = datetime ?? (now ? new Date() : undefined)

const resolvedDatetimeString =
  resolvedDatetime instanceof Date ? resolvedDatetime.toISOString() : resolvedDatetime

const parsedDate =
  typeof resolvedDatetimeString === 'string' ? new Date(resolvedDatetimeString) : undefined

const isValidDate = parsedDate instanceof Date && !Number.isNaN(parsedDate.getTime())

const dateStyleByFormatStyle: Record<NonNullable<Props['formatStyle']>, Intl.DateTimeFormatOptions['dateStyle']> = {
  long: 'long',
  short: 'short',
  narrow: 'short',
}

const hasExplicitParts = Boolean(weekday || year || month || day || hour || minute || second || timeZoneName)

const fallbackText = (() => {
  if (!resolvedDatetimeString) {
    return ''
  }

  if (format === 'duration') {
    return typeof resolvedDatetimeString === 'string' ? resolvedDatetimeString : ''
  }

  if (!isValidDate || !parsedDate) {
    return ''
  }

  const options: Intl.DateTimeFormatOptions = hasExplicitParts
    ? {
        weekday,
        year,
        month,
        day,
        hour,
        minute,
        second,
        timeZoneName,
        timeZone,
      }
    : {
        dateStyle: formatStyle ? dateStyleByFormatStyle[formatStyle] : 'medium',
        timeZone,
      }

  try {
    return new Intl.DateTimeFormat(undefined, options).format(parsedDate)
  } catch {
    return ''
  }
})()
---

<script>
  import '@github/relative-time-element'
</script>

<relative-time
  datetime={resolvedDatetimeString}
  {...{
    ...attrs,
    format,
    'format-style': formatStyle,
    'time-zone-name': timeZoneName,
    'time-zone': timeZone,
  }}
>
  {/** Closing tag must be on same line to prevent trailing space */ }
  <slot>{fallbackText}</slot></relative-time>{timeZone ? ` (${timeZone})` : ''}
