---
title: "Workload Identity: Eliminating Long-Lived Keys"
description: "Replacing service account keys with workload identity federation for secure, keyless cloud access."
cover: "./cover.png"
coverAlt: "TODO"
author: "kevin-brown"
publishDate: 2024-01-15
tags: ["cloud-platforms"]
featured: true
---

*[AWS]: Amazon Web Services
*[CI]: Continuous Integration
*[EKS]: Elastic Kubernetes Service
*[GCP]: Google Cloud Platform
*[GKE]: Google Kubernetes Engine
*[IAM]: Identity and Access Management
*[IdP]: Identity Provider
*[JWT]: JSON Web Token
*[OIDC]: OpenID Connect
*[STS]: Security Token Service
*[SPIFFE]: Secure Production Identity Framework for Everyone

Identity federation mechanics, provider configuration, migration strategies, and the failure modes when identity binding breaks.

Long-lived keys are a liability; workload identity eliminates them.

## The Problem with Long-Lived Keys

Service account keys are static credentials that live forever until explicitly rotated—which they rarely are.

### Key Management Failures

Why service account keys become security liabilities.

```typescript
// The typical key lifecycle (anti-pattern)
interface ServiceAccountKeyLifecycle {
  creation: {
    who: string       // Usually someone who left the company
    when: Date        // Years ago
    why: string       // "Needed for CI pipeline"
    documented: false // Almost never
  }

  storage: {
    location: 'environment_variable' | 'secrets_manager' | 'git_repo' | 'slack_dm'
    encrypted: boolean     // Sometimes
    accessControlled: boolean  // Rarely
    copies: number        // Unknown, probably many
  }

  rotation: {
    scheduled: false
    lastRotated: never
    rotationProcess: undefined
  }

  compromiseDetection: {
    monitoring: false
    alerting: false
    auditLogging: 'maybe'
  }
}

// Real-world key compromise timeline
const compromiseTimeline = [
  { day: 0, event: 'Key created for CI pipeline' },
  { day: 30, event: 'Key copied to second repo for convenience' },
  { day: 90, event: 'Developer stores key in .env file' },
  { day: 180, event: '.env accidentally committed to git' },
  { day: 181, event: 'Git history rewritten, but key still in reflog' },
  { day: 365, event: 'Repo made public for open source release' },
  { day: 366, event: 'Automated scanners find key in git history' },
  { day: 367, event: 'Cryptomining instances spinning up in your account' }
]
```

| Key Risk | Impact | Detection Difficulty |
|----------|--------|---------------------|
| Key leaked in git history | Full account access | Hard—requires scanning |
| Key shared via Slack/email | Credential sprawl | Very hard—no audit trail |
| Key in CI environment variables | Exposure via logs | Medium—log analysis |
| Key never rotated | Extended compromise window | Easy—check creation date |
| Key with excessive permissions | Lateral movement | Medium—IAM analysis |
| Key owner left company | Orphaned access | Easy—compare to HR data |

<Callout type="danger">
Every long-lived credential is an attack vector. Service account keys have been the root cause of major cloud breaches. Workload identity federation eliminates this entire category of risk by replacing static keys with short-lived, automatically-rotated tokens.
</Callout>

### The Federation Alternative

How workload identity changes the security model.

```
Mermaid diagram: Long-lived keys vs workload identity comparison.
Long-Lived Keys:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  CI Runner ──────── Service Account Key ──────► Cloud API  │
│                     (Never expires)                         │
│                     (Stored somewhere)                      │
│                     (Who has copies?)                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘

Workload Identity Federation:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  CI Runner                                                  │
│      │                                                      │
│      ▼ (1) Request OIDC token                              │
│  CI Platform IdP                                            │
│      │                                                      │
│      ▼ (2) Issue JWT with claims                           │
│  Cloud STS                                                  │
│      │  - Verify signature                                  │
│      │  - Check issuer trust                               │
│      │  - Validate claims against policy                   │
│      ▼                                                      │
│  Short-lived credentials (1 hour)                          │
│      │                                                      │
│      ▼ (3) Access cloud resources                          │
│  Cloud API                                                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## Federation Mechanics

Understanding how identity federation actually works under the hood.

### OIDC Token Anatomy

The JWT that proves workload identity.

```typescript
// OIDC token structure from GitHub Actions
interface GitHubActionsOIDCToken {
  header: {
    alg: 'RS256'
    typ: 'JWT'
    kid: string  // Key ID for signature verification
  }

  payload: {
    // Standard OIDC claims
    iss: string   // "https://token.actions.githubusercontent.com"
    sub: string   // "repo:owner/repo:ref:refs/heads/main"
    aud: string   // Audience—your cloud provider
    exp: number   // Expiration timestamp
    iat: number   // Issued at timestamp
    nbf: number   // Not valid before
    jti: string   // Unique token ID

    // GitHub-specific claims
    repository: string        // "owner/repo"
    repository_owner: string  // "owner"
    repository_id: string     // "123456789"
    repository_visibility: 'public' | 'private' | 'internal'

    actor: string             // User who triggered workflow
    actor_id: string

    workflow: string          // Workflow file name
    workflow_ref: string      // Full workflow reference

    event_name: string        // "push", "pull_request", etc.
    ref: string               // "refs/heads/main"
    ref_type: string          // "branch" or "tag"

    job_workflow_ref: string  // Reusable workflow reference
    runner_environment: string // "github-hosted" or "self-hosted"

    environment: string       // Deployment environment name
  }

  signature: string  // RS256 signature for verification
}

// Example decoded token
const exampleToken = {
  iss: "https://token.actions.githubusercontent.com",
  sub: "repo:myorg/myrepo:environment:production",
  aud: "https://iam.googleapis.com/projects/123/locations/global/workloadIdentityPools/github-pool/providers/github-provider",
  repository: "myorg/myrepo",
  repository_owner: "myorg",
  environment: "production",
  ref: "refs/heads/main",
  workflow: "deploy.yml",
  actor: "developer@example.com"
}
```

### Token Exchange Flow

The complete flow from workload to cloud credentials.

```
Mermaid diagram: Token exchange sequence.
Workload              IdP                 Cloud STS            Cloud IAM
   │                   │                      │                    │
   │ (1) Request       │                      │                    │
   │ OIDC token        │                      │                    │
   │──────────────────►│                      │                    │
   │                   │                      │                    │
   │ (2) JWT signed    │                      │                    │
   │ with IdP key      │                      │                    │
   │◄──────────────────│                      │                    │
   │                   │                      │                    │
   │ (3) Exchange JWT for cloud credentials  │                    │
   │──────────────────────────────────────────►│                    │
   │                   │                      │                    │
   │                   │  (4) Fetch IdP       │                    │
   │                   │  JWKS (cached)       │                    │
   │                   │◄─────────────────────│                    │
   │                   │                      │                    │
   │                   │  (5) Verify:         │                    │
   │                   │  - Signature valid   │                    │
   │                   │  - Issuer trusted    │                    │
   │                   │  - Claims match      │                    │
   │                   │  - Not expired       │                    │
   │                   │                      │                    │
   │                   │                      │ (6) Lookup         │
   │                   │                      │ service account    │
   │                   │                      │─────────────────────►│
   │                   │                      │                    │
   │                   │                      │◄────────────────────│
   │                   │                      │                    │
   │ (7) Short-lived access token            │                    │
   │◄─────────────────────────────────────────│                    │
   │                   │                      │                    │
   │ Token valid for 1 hour                  │                    │
   │ Automatically refreshed                 │                    │
```

### Attribute Mapping and Conditions

Controlling which workloads can assume which identities.

```typescript
// Attribute mapping configuration
interface AttributeMapping {
  // Map OIDC claims to cloud provider attributes
  mappings: Record<string, string>

  // Condition expression for access control
  condition: string
}

// GCP attribute mapping example
const gcpMapping: AttributeMapping = {
  mappings: {
    // Standard mappings
    'google.subject': 'assertion.sub',
    'attribute.actor': 'assertion.actor',
    'attribute.repository': 'assertion.repository',
    'attribute.repository_owner': 'assertion.repository_owner',
    'attribute.ref': 'assertion.ref',
    'attribute.environment': 'assertion.environment',

    // Custom derived attributes
    'attribute.repository_full': 'assertion.repository_owner + "/" + assertion.repository'
  },

  // Only allow main branch of specific repo in production environment
  condition: `
    attribute.repository_owner == "myorg" &&
    attribute.repository == "myorg/production-deploy" &&
    attribute.ref == "refs/heads/main" &&
    attribute.environment == "production"
  `
}

// AWS trust policy condition example
const awsTrustCondition = {
  StringEquals: {
    "token.actions.githubusercontent.com:aud": "sts.amazonaws.com",
    "token.actions.githubusercontent.com:sub": "repo:myorg/myrepo:environment:production"
  },
  StringLike: {
    "token.actions.githubusercontent.com:sub": "repo:myorg/*:ref:refs/heads/main"
  }
}
```

## Provider Configuration

Setting up workload identity federation on major cloud platforms.

### AWS: IAM Roles for GitHub Actions

Complete setup for AWS federation with GitHub.

```hcl
# Terraform configuration for AWS + GitHub Actions federation

# OIDC provider for GitHub
resource "aws_iam_openid_connect_provider" "github" {
  url             = "https://token.actions.githubusercontent.com"
  client_id_list  = ["sts.amazonaws.com"]
  thumbprint_list = ["6938fd4d98bab03faadb97b34396831e3780aea1"]

  tags = {
    Purpose = "GitHub Actions OIDC federation"
  }
}

# IAM role that GitHub Actions can assume
resource "aws_iam_role" "github_actions_deploy" {
  name = "github-actions-deploy"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = {
          Federated = aws_iam_openid_connect_provider.github.arn
        }
        Action = "sts:AssumeRoleWithWebIdentity"
        Condition = {
          StringEquals = {
            "token.actions.githubusercontent.com:aud" = "sts.amazonaws.com"
          }
          StringLike = {
            # Restrict to specific repo and branch
            "token.actions.githubusercontent.com:sub" = "repo:myorg/myrepo:ref:refs/heads/main"
          }
        }
      }
    ]
  })
}

# Attach permissions to the role
resource "aws_iam_role_policy_attachment" "github_actions_deploy" {
  role       = aws_iam_role.github_actions_deploy.name
  policy_arn = aws_iam_policy.deploy_permissions.arn
}

# Fine-grained deploy permissions
resource "aws_iam_policy" "deploy_permissions" {
  name = "github-actions-deploy-permissions"

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid    = "ECRAccess"
        Effect = "Allow"
        Action = [
          "ecr:GetAuthorizationToken",
          "ecr:BatchCheckLayerAvailability",
          "ecr:PutImage",
          "ecr:InitiateLayerUpload",
          "ecr:UploadLayerPart",
          "ecr:CompleteLayerUpload"
        ]
        Resource = "*"
      },
      {
        Sid    = "ECSDeployment"
        Effect = "Allow"
        Action = [
          "ecs:UpdateService",
          "ecs:DescribeServices",
          "ecs:DescribeTaskDefinition",
          "ecs:RegisterTaskDefinition"
        ]
        Resource = [
          "arn:aws:ecs:*:*:service/production-cluster/*",
          "arn:aws:ecs:*:*:task-definition/production-*"
        ]
      }
    ]
  })
}
```

```yaml
# GitHub Actions workflow using OIDC
name: Deploy to AWS

on:
  push:
    branches: [main]

permissions:
  id-token: write   # Required for OIDC token
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::123456789012:role/github-actions-deploy
          aws-region: us-east-1
          # No access keys needed!

      - name: Deploy to ECS
        run: |
          aws ecs update-service \
            --cluster production-cluster \
            --service web-service \
            --force-new-deployment
```

### GCP: Workload Identity Federation

Google Cloud configuration for external workloads.

```hcl
# GCP Workload Identity Pool and Provider

# Identity pool (container for providers)
resource "google_iam_workload_identity_pool" "github" {
  project                   = var.project_id
  workload_identity_pool_id = "github-actions-pool"
  display_name              = "GitHub Actions Pool"
  description               = "Identity pool for GitHub Actions workflows"
}

# OIDC provider within the pool
resource "google_iam_workload_identity_pool_provider" "github" {
  project                            = var.project_id
  workload_identity_pool_id          = google_iam_workload_identity_pool.github.workload_identity_pool_id
  workload_identity_pool_provider_id = "github-provider"
  display_name                       = "GitHub Actions Provider"

  # GitHub's OIDC issuer
  oidc {
    issuer_uri = "https://token.actions.githubusercontent.com"
  }

  # Map GitHub claims to GCP attributes
  attribute_mapping = {
    "google.subject"             = "assertion.sub"
    "attribute.actor"            = "assertion.actor"
    "attribute.repository"       = "assertion.repository"
    "attribute.repository_owner" = "assertion.repository_owner"
    "attribute.ref"              = "assertion.ref"
  }

  # Only allow tokens from our organization
  attribute_condition = "assertion.repository_owner == 'myorg'"
}

# Service account for GitHub Actions to impersonate
resource "google_service_account" "github_actions" {
  project      = var.project_id
  account_id   = "github-actions-deploy"
  display_name = "GitHub Actions Deploy"
  description  = "Service account for GitHub Actions deployments"
}

# Allow workload identity to impersonate service account
resource "google_service_account_iam_binding" "github_actions_impersonation" {
  service_account_id = google_service_account.github_actions.name
  role               = "roles/iam.workloadIdentityUser"

  members = [
    # Bind to specific repository
    "principalSet://iam.googleapis.com/${google_iam_workload_identity_pool.github.name}/attribute.repository/myorg/production-deploy"
  ]
}

# Grant permissions to service account
resource "google_project_iam_member" "github_actions_gke" {
  project = var.project_id
  role    = "roles/container.developer"
  member  = "serviceAccount:${google_service_account.github_actions.email}"
}
```

```yaml
# GitHub Actions workflow for GCP
name: Deploy to GKE

on:
  push:
    branches: [main]

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to GCP
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: 'projects/123456789/locations/global/workloadIdentityPools/github-actions-pool/providers/github-provider'
          service_account: 'github-actions-deploy@myproject.iam.gserviceaccount.com'

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Deploy to GKE
        run: |
          gcloud container clusters get-credentials production-cluster --zone us-central1-a
          kubectl apply -f k8s/
```

### Azure: Federated Identity Credentials

Azure AD federation with GitHub Actions.

```hcl
# Azure federated identity configuration

# App registration (service principal)
resource "azuread_application" "github_actions" {
  display_name = "github-actions-deploy"

  owners = [data.azuread_client_config.current.object_id]
}

resource "azuread_service_principal" "github_actions" {
  client_id = azuread_application.github_actions.client_id

  owners = [data.azuread_client_config.current.object_id]
}

# Federated credential for GitHub Actions
resource "azuread_application_federated_identity_credential" "github_main" {
  application_id = azuread_application.github_actions.id
  display_name   = "github-actions-main-branch"
  description    = "GitHub Actions federation for main branch"

  audiences = ["api://AzureADTokenExchange"]
  issuer    = "https://token.actions.githubusercontent.com"
  subject   = "repo:myorg/myrepo:ref:refs/heads/main"
}

# Environment-specific credential
resource "azuread_application_federated_identity_credential" "github_production" {
  application_id = azuread_application.github_actions.id
  display_name   = "github-actions-production-env"
  description    = "GitHub Actions federation for production environment"

  audiences = ["api://AzureADTokenExchange"]
  issuer    = "https://token.actions.githubusercontent.com"
  subject   = "repo:myorg/myrepo:environment:production"
}

# Role assignment on resource group
resource "azurerm_role_assignment" "github_actions_contributor" {
  scope                = azurerm_resource_group.production.id
  role_definition_name = "Contributor"
  principal_id         = azuread_service_principal.github_actions.object_id
}
```

```yaml
# GitHub Actions workflow for Azure
name: Deploy to Azure

on:
  push:
    branches: [main]

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production

    steps:
      - uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          # No client secret needed!

      - name: Deploy to Azure
        uses: azure/webapps-deploy@v3
        with:
          app-name: production-webapp
          package: ./dist
```

## Kubernetes Workload Identity

Pod identity for accessing cloud services from Kubernetes.

### EKS Pod Identity

AWS workload identity for EKS pods.

```hcl
# EKS OIDC provider and IAM roles for service accounts

# Get OIDC issuer from EKS cluster
data "aws_eks_cluster" "cluster" {
  name = var.cluster_name
}

# Create OIDC provider for the cluster
resource "aws_iam_openid_connect_provider" "eks" {
  url             = data.aws_eks_cluster.cluster.identity[0].oidc[0].issuer
  client_id_list  = ["sts.amazonaws.com"]
  thumbprint_list = [data.tls_certificate.eks.certificates[0].sha1_fingerprint]
}

# IAM role for a specific service account
resource "aws_iam_role" "app_s3_access" {
  name = "eks-app-s3-access"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = {
          Federated = aws_iam_openid_connect_provider.eks.arn
        }
        Action = "sts:AssumeRoleWithWebIdentity"
        Condition = {
          StringEquals = {
            "${replace(aws_iam_openid_connect_provider.eks.url, "https://", "")}:sub" = "system:serviceaccount:production:app-service-account"
            "${replace(aws_iam_openid_connect_provider.eks.url, "https://", "")}:aud" = "sts.amazonaws.com"
          }
        }
      }
    ]
  })
}

# Attach S3 access policy
resource "aws_iam_role_policy" "app_s3_access" {
  name = "s3-access"
  role = aws_iam_role.app_s3_access.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "s3:GetObject",
          "s3:PutObject",
          "s3:ListBucket"
        ]
        Resource = [
          "arn:aws:s3:::app-data-bucket",
          "arn:aws:s3:::app-data-bucket/*"
        ]
      }
    ]
  })
}
```

```yaml
# Kubernetes service account with IAM role annotation
apiVersion: v1
kind: ServiceAccount
metadata:
  name: app-service-account
  namespace: production
  annotations:
    # This annotation binds the SA to the IAM role
    eks.amazonaws.com/role-arn: arn:aws:iam::123456789012:role/eks-app-s3-access
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app
  namespace: production
spec:
  template:
    spec:
      serviceAccountName: app-service-account  # Use annotated SA
      containers:
        - name: app
          image: myapp:latest
          env:
            # AWS SDK automatically uses pod identity
            - name: AWS_REGION
              value: us-east-1
            # No AWS_ACCESS_KEY_ID or AWS_SECRET_ACCESS_KEY needed!
```

### GKE Workload Identity

GCP workload identity for GKE pods.

```hcl
# GKE Workload Identity configuration

# Kubernetes service account to GCP service account binding
resource "google_service_account_iam_binding" "workload_identity" {
  service_account_id = google_service_account.app.name
  role               = "roles/iam.workloadIdentityUser"

  members = [
    "serviceAccount:${var.project_id}.svc.id.goog[production/app-ksa]"
  ]
}

# GCP service account for the application
resource "google_service_account" "app" {
  account_id   = "app-workload"
  display_name = "Application Workload Identity"
}

# Grant permissions to the service account
resource "google_project_iam_member" "app_storage" {
  project = var.project_id
  role    = "roles/storage.objectViewer"
  member  = "serviceAccount:${google_service_account.app.email}"
}
```

```yaml
# Kubernetes configuration for GKE Workload Identity
apiVersion: v1
kind: ServiceAccount
metadata:
  name: app-ksa
  namespace: production
  annotations:
    # Bind to GCP service account
    iam.gke.io/gcp-service-account: app-workload@myproject.iam.gserviceaccount.com
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app
  namespace: production
spec:
  template:
    spec:
      serviceAccountName: app-ksa
      # Required for Workload Identity
      nodeSelector:
        iam.gke.io/gke-metadata-server-enabled: "true"
      containers:
        - name: app
          image: gcr.io/myproject/app:latest
          # GCP client libraries automatically use workload identity
```

```
Mermaid diagram: Kubernetes workload identity flow.
┌─────────────────────────────────────────────────────────────┐
│                    Kubernetes Cluster                        │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ Pod                                                  │   │
│  │   serviceAccountName: app-ksa                        │   │
│  │                                                      │   │
│  │   Container                                          │   │
│  │     │                                                │   │
│  │     ▼ (1) Request cloud credentials                 │   │
│  │   SDK/Client Library                                │   │
│  └─────│────────────────────────────────────────────────┘   │
│        │                                                     │
│        ▼ (2) Request projected token                        │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ Token Projection (via volume mount)                  │   │
│  │   /var/run/secrets/tokens/gcp-ksa-token             │   │
│  │   Audience: cloud provider                           │   │
│  │   Expires: 1 hour (auto-refreshed)                   │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└────────────────────────│────────────────────────────────────┘
                         │
                         ▼ (3) Exchange token
┌─────────────────────────────────────────────────────────────┐
│ Cloud IAM                                                    │
│   - Verify token signature                                   │
│   - Check namespace/service account binding                  │
│   - Issue short-lived credentials                           │
└─────────────────────────────────────────────────────────────┘
```

## Migration Strategy

Moving from static keys to workload identity federation.

### Migration Planning

Systematic approach to eliminating long-lived keys.

```typescript
// Key inventory and migration tracking
interface KeyInventory {
  id: string
  serviceAccount: string
  createdDate: Date
  createdBy: string
  lastUsed: Date | null
  usageLocation: UsageLocation[]
  migrationStatus: MigrationStatus
  risk: RiskLevel
}

interface UsageLocation {
  type: 'ci_pipeline' | 'kubernetes' | 'application' | 'developer_machine' | 'unknown'
  platform: string           // GitHub Actions, Jenkins, EKS, etc.
  environment: string        // production, staging, development
  workload: string           // Name of workflow/deployment
  canMigrate: boolean
  blockers: string[]
}

type MigrationStatus =
  | 'not_started'
  | 'analyzing'
  | 'federation_configured'
  | 'dual_auth_testing'
  | 'migrated'
  | 'key_disabled'
  | 'key_deleted'

type RiskLevel = 'critical' | 'high' | 'medium' | 'low'

// Migration prioritization
function prioritizeKeyMigration(inventory: KeyInventory[]): KeyInventory[] {
  return inventory.sort((a, b) => {
    // Critical risk first
    const riskOrder = { critical: 0, high: 1, medium: 2, low: 3 }
    if (riskOrder[a.risk] !== riskOrder[b.risk]) {
      return riskOrder[a.risk] - riskOrder[b.risk]
    }

    // Older keys next (more likely compromised)
    return a.createdDate.getTime() - b.createdDate.getTime()
  })
}
```

| Migration Phase | Duration | Activities | Success Criteria |
|----------------|----------|------------|------------------|
| Discovery | 1-2 weeks | Inventory all keys, identify usage, assess risk | Complete inventory with owner/usage mapping |
| Foundation | 2-4 weeks | Configure OIDC providers, create federated identities | Federation infrastructure deployed and tested |
| Pilot Migration | 2-4 weeks | Migrate low-risk, non-production workloads | 3-5 workloads using federation successfully |
| Production Migration | 4-8 weeks | Migrate production workloads systematically | All production workloads using federation |
| Key Retirement | 2-4 weeks | Disable then delete old keys | Zero active long-lived keys |

### Dual Authentication Period

Running both authentication methods during transition.

```yaml
# GitHub Actions workflow with fallback
name: Deploy with Federation

on:
  push:
    branches: [main]

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      # Try OIDC first
      - name: Configure AWS credentials (OIDC)
        id: oidc-auth
        uses: aws-actions/configure-aws-credentials@v4
        continue-on-error: true
        with:
          role-to-assume: arn:aws:iam::123456789012:role/github-actions-deploy
          aws-region: us-east-1

      # Fallback to key if OIDC fails (temporary)
      - name: Configure AWS credentials (Key Fallback)
        if: steps.oidc-auth.outcome == 'failure'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      # Log which auth method was used
      - name: Log authentication method
        run: |
          if [ "${{ steps.oidc-auth.outcome }}" == "success" ]; then
            echo "::notice::Using OIDC federation"
          else
            echo "::warning::Fell back to static key - investigate OIDC failure"
          fi

      - name: Deploy
        run: ./deploy.sh
```

<Callout type="info">
Enable CloudTrail (AWS), Cloud Audit Logs (GCP), or Azure Activity Logs to monitor which authentication method is being used. Look for `AssumeRoleWithWebIdentity` vs `AssumeRole` or direct key authentication to track migration progress.
</Callout>

### Key Retirement Checklist

Safe decommissioning of old keys.

```typescript
// Key retirement workflow
interface KeyRetirementChecklist {
  keyId: string
  serviceAccount: string

  preRetirement: {
    // Verify all workloads migrated
    allWorkloadsMigrated: boolean
    workloadMigrationDate: Date

    // Monitor for any usage
    monitoringPeriodDays: number  // Recommend 14-30 days
    usageDuringMonitoring: boolean

    // Document for audit
    migrationDocumented: boolean
    approvalObtained: boolean
    approvedBy: string
  }

  retirement: {
    // Disable before delete
    disabledDate: Date
    disabledBy: string

    // Monitor post-disable
    postDisableMonitoringDays: number  // Recommend 7 days
    errorsAfterDisable: boolean

    // Final deletion
    deletedDate: Date
    deletedBy: string
    deletionTicket: string
  }

  postRetirement: {
    // Verify no impact
    verificationDate: Date
    productionImpact: boolean

    // Archive documentation
    documentationArchived: boolean
  }
}

// Retirement script
async function retireKey(keyId: string): Promise<void> {
  // Step 1: Verify no recent usage
  const usage = await getKeyUsage(keyId, { days: 30 })
  if (usage.length > 0) {
    throw new Error(`Key ${keyId} still in use: ${usage.length} calls in last 30 days`)
  }

  // Step 2: Disable key (don't delete yet)
  await disableKey(keyId)
  console.log(`Key ${keyId} disabled. Monitoring for 7 days...`)

  // Step 3: Wait and monitor
  await scheduleKeyDeletion(keyId, { delayDays: 7 })

  // Step 4: Delete after monitoring period
  // Runs via scheduled job after 7 days
}
```

## Failure Modes and Troubleshooting

When federation breaks and how to fix it.

### Common Failure Scenarios

What goes wrong with workload identity federation.

```typescript
// Federation failure scenarios
interface FederationFailure {
  error: string
  cause: string
  symptoms: string[]
  resolution: string
}

const failureScenarios: FederationFailure[] = [
  {
    error: 'InvalidIdentityToken',
    cause: 'Token expired or malformed',
    symptoms: [
      'Sudden authentication failures',
      'Works after workflow retry',
      'Timing-related failures'
    ],
    resolution: 'Check clock skew, ensure token is fresh, verify OIDC endpoint availability'
  },
  {
    error: 'AccessDenied: Not authorized to perform sts:AssumeRoleWithWebIdentity',
    cause: 'Trust policy condition mismatch',
    symptoms: [
      'Works in some branches but not others',
      'Works for some repos but not others',
      'Worked yesterday, fails today'
    ],
    resolution: 'Check sub claim in token vs trust policy condition. Common issues: branch name changed, repo renamed, environment name typo'
  },
  {
    error: 'InvalidParameterValue: Audience in token does not match',
    cause: 'Audience claim mismatch',
    symptoms: [
      'Authentication always fails',
      'Different error than before migration'
    ],
    resolution: 'Verify audience in workflow matches OIDC provider client_id_list'
  },
  {
    error: 'WebIdentityErr: failed to retrieve credentials',
    cause: 'OIDC provider unreachable',
    symptoms: [
      'Intermittent failures',
      'Correlated with network issues',
      'Multiple workflows fail simultaneously'
    ],
    resolution: 'Check GitHub/GitLab status, verify network connectivity, check for rate limiting'
  },
  {
    error: 'The specified service account does not exist',
    cause: 'Service account deleted or wrong binding',
    symptoms: [
      'Worked before infrastructure change',
      'Multiple workloads fail after Terraform apply'
    ],
    resolution: 'Verify service account exists, check workload identity binding matches namespace/service account'
  }
]
```

### Debugging Token Claims

Inspecting OIDC tokens to diagnose issues.

```bash
# Decode GitHub Actions OIDC token (in workflow)
- name: Debug OIDC token claims
  run: |
    # Get the token
    TOKEN=$(curl -s -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
      "$ACTIONS_ID_TOKEN_REQUEST_URL&audience=sts.amazonaws.com")

    # Extract and decode the JWT (middle part)
    echo "$TOKEN" | jq -r '.value' | cut -d. -f2 | base64 -d 2>/dev/null | jq .

# Example output:
# {
#   "sub": "repo:myorg/myrepo:ref:refs/heads/feature/test",
#   "repository": "myorg/myrepo",
#   "repository_owner": "myorg",
#   "ref": "refs/heads/feature/test",
#   "environment": "",
#   ...
# }

# Compare with trust policy expectation:
# "sub": "repo:myorg/myrepo:ref:refs/heads/main"
#                                  ^ mismatch: feature/test != main
```

```typescript
// Token claim debugging utility
function debugTokenClaims(token: string, expectedClaims: Record<string, string>): void {
  const [, payloadB64] = token.split('.')
  const payload = JSON.parse(Buffer.from(payloadB64, 'base64').toString())

  console.log('Token claims:')
  console.log(JSON.stringify(payload, null, 2))

  console.log('\nClaim comparison:')
  for (const [key, expected] of Object.entries(expectedClaims)) {
    const actual = payload[key]
    const matches = actual === expected

    console.log(`  ${key}:`)
    console.log(`    Expected: ${expected}`)
    console.log(`    Actual:   ${actual}`)
    console.log(`    Match:    ${matches ? '✓' : '✗ MISMATCH'}`)
  }
}

// Usage in debugging
debugTokenClaims(oidcToken, {
  iss: 'https://token.actions.githubusercontent.com',
  sub: 'repo:myorg/myrepo:ref:refs/heads/main',
  aud: 'sts.amazonaws.com',
  repository_owner: 'myorg'
})
```

<Callout type="warning">
The `sub` claim format changes based on workflow context:
- Branch push: `repo:owner/repo:ref:refs/heads/branch`
- Tag push: `repo:owner/repo:ref:refs/tags/v1.0.0`
- Pull request: `repo:owner/repo:pull_request`
- Environment: `repo:owner/repo:environment:production`
Ensure your trust policy conditions match the actual claim format for your use case.
</Callout>

## Conclusion

Long-lived service account keys represent one of the most common and preventable security vulnerabilities in cloud deployments. Every key is a potential breach vector—keys get committed to repositories, shared via insecure channels, copied across systems, and forgotten about until they appear in a breach notification. Workload identity federation eliminates this entire risk category by replacing static credentials with short-lived tokens that are automatically issued, scoped to specific workloads, and impossible to leak because they expire within minutes to hours. The setup requires upfront investment: configuring OIDC providers, establishing trust relationships, mapping claims to permissions, and updating all your CI/CD workflows. But once complete, you have zero long-lived credentials to rotate, monitor for compromise, or accidentally expose. Start with your highest-risk, most-used credentials—CI/CD pipelines that deploy to production. Configure federation in parallel with existing key auth, verify it works, then delete the keys. The migration path is well-documented, the failure modes are understandable, and the security improvement is substantial. Your future self, who will not have to respond to a 2 AM page about compromised credentials, will thank you.

---

## Cover Image Prompts

### Prompt 1: Broken Key vs Digital Identity
Split image showing an old physical key broken in half on one side, and flowing digital identity patterns (biometric, tokens, waves) on the other. The transition from physical to digital authentication.

### Prompt 2: Identity Federation Handshake
Abstract visualization of two systems exchanging trust—one representing a CI platform (GitHub logo stylized), one representing cloud (AWS/GCP/Azure abstract), with glowing tokens passing between them through secure channels.

### Prompt 3: Vault Door with Expiring Access
Modern bank vault door with a prominent digital countdown timer showing "00:59:42" remaining. Short-lived access vs permanent keys. Clean, minimal, high-security aesthetic.

### Prompt 4: Chain of Trust Visualization
Abstract art showing a chain made of interlocking digital certificates and tokens, each link glowing with verification status, representing the chain of trust from workload to cloud.

### Prompt 5: Key Graveyard at Sunset
Atmospheric photograph of old-fashioned metal keys scattered and abandoned in grass, with a sunset sky. The end of the era of long-lived credentials. Melancholic but hopeful tone.
