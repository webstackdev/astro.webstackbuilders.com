---
title: "Contract Testing for Internal APIs"
description: "Consumer-driven contracts that catch breaking changes without heavyweight tooling or coordination overhead."
cover: "./cover.png"
coverAlt: "TODO"
author: "kevin-brown"
publishDate: 2024-01-15
tags: ["apis-and-gateways"]
featured: true
---

*[CDC]: Consumer-Driven Contracts
*[API]: Application Programming Interface
*[CI]: Continuous Integration
*[CD]: Continuous Deployment
*[SUT]: System Under Test
*[JSON]: JavaScript Object Notation

# Contract Testing for Internal APIs

## Introduction

Brief overview of the coordination problem in microservices: when Service A depends on Service B's API, how do you ensure changes to B don't break A? Integration tests are slow and flaky; relying on documentation gets stale; manual coordination doesn't scale. This section introduces consumer-driven contracts as a lightweight alternative that catches breaking changes at PR time.

_Include a real scenario: a team ships a "minor" API change (renaming a field from `userId` to `user_id`), confident their OpenAPI spec is correct. Three services break in production because they consumed the old field name. Contract tests would have caught this before merge._

<Callout type="info">
Consumer-driven contracts flip the traditional testing model: instead of the provider defining what it offers and hoping consumers adapt, consumers define what they need and providers verify they deliver it.
</Callout>

## The Problem with Traditional Integration Testing

### Why Integration Tests Fail at Scale

Explain the limitations of end-to-end integration tests for API compatibility.

```text
Integration Test Problems:

1. Environment Coordination
   - Need all services running simultaneously
   - Shared test databases get corrupted
   - Port conflicts, network issues

2. Speed
   - Minutes to hours per test run
   - Developers stop running them locally
   - CI feedback loop too slow

3. Flakiness
   - Network timeouts
   - Race conditions
   - Shared state pollution

4. Debugging
   - Failure in service D caused by change in service A
   - Stack traces span multiple services
   - Hard to reproduce locally
```

```mermaid
graph TD
    A[Service A] -->|Calls| B[Service B]
    B -->|Calls| C[Service C]
    C -->|Calls| D[Service D]

    A -.->|Integration Test| B
    A -.->|Integration Test| C
    A -.->|Integration Test| D

    subgraph Problems
        E[Slow: Minutes+]
        F[Flaky: Network]
        G[Brittle: Shared State]
    end
```
Figure: Integration tests create dependencies across all services.

| Testing Approach | Speed | Reliability | Isolation | Catches Breaking Changes |
|------------------|-------|-------------|-----------|-------------------------|
| Unit tests | Fast | High | Complete | No (mocks hide reality) |
| Integration tests | Slow | Low | None | Yes (but late) |
| E2E tests | Very slow | Very low | None | Yes (in production-like) |
| Contract tests | Fast | High | Complete | Yes (at PR time) |

Table: Comparison of testing approaches for API compatibility.

### The Documentation Lie

```yaml title="openapi-drift.yaml"
# What the OpenAPI spec says
paths:
  /users/{id}:
    get:
      responses:
        200:
          content:
            application/json:
              schema:
                type: object
                properties:
                  userId:      # <-- Spec says userId
                    type: string
                  email:
                    type: string

# What the implementation actually returns
# {
#   "user_id": "123",  <-- Implementation uses user_id
#   "email": "test@example.com"
# }

# The spec was written once and never updated
# Consumers who trusted the spec are now broken
```
Code: OpenAPI specs drift from implementation without enforcement.

<Callout type="warning">
Documentation without enforcement is fiction. Schemas describe intent; contract tests verify reality.
</Callout>

## Consumer-Driven Contracts Explained

### The Core Concept

Explain how CDC inverts the traditional provider-centric model.

```mermaid
graph LR
    subgraph Traditional
        P1[Provider] -->|Defines| S1[Schema]
        S1 -->|Consumed by| C1[Consumer]
        C1 -.->|Hopes it works| P1
    end

    subgraph Consumer-Driven
        C2[Consumer] -->|Defines| CT[Contract]
        CT -->|Verified by| P2[Provider]
        P2 -->|Guarantees| C2
    end
```
Figure: Traditional vs consumer-driven contract model.

```text
Consumer-Driven Contract Flow:

1. Consumer defines what it needs
   - "I call GET /users/123"
   - "I expect { userId: string, email: string }"

2. Contract is stored (Pact Broker, file, etc.)

3. Provider verifies it can satisfy the contract
   - Provider runs tests against its real implementation
   - Tests use the consumer's expectations

4. Both sides know compatibility BEFORE deployment
   - Consumer knows provider will deliver what it needs
   - Provider knows which consumers depend on which fields
```

### What Goes in a Contract

Define the scope of contract testing—what to test and what not to test.

```yaml title="contract-scope.yaml"
in_scope:
  # API shape
  - request_path: "/users/{id}"
  - request_method: "GET"
  - request_headers: ["Authorization", "Content-Type"]
  - response_status: 200
  - response_body_structure:
      userId: "string"
      email: "string"
      createdAt: "ISO8601 datetime"

out_of_scope:
  # Business logic
  - specific_user_data: "Don't test 'user 123 has email x'"
  - database_state: "Consumer shouldn't know provider's DB"
  - exact_error_messages: "Just test status codes"
  - performance: "That's load testing"
  - security: "That's security testing"
```
Code: Defining contract scope—structure, not business logic.

<Callout type="success">
Contract tests verify the API contract, not business logic. They answer "does the response have a userId field that's a string?" not "does user 123 exist?"
</Callout>

## Pact: The De Facto Standard

### Pact Architecture

Explain how Pact works at a technical level.

```mermaid
sequenceDiagram
    participant CT as Consumer Test
    participant MS as Mock Server
    participant PB as Pact Broker
    participant PT as Provider Test
    participant PS as Provider Service

    CT->>MS: Define expectations
    CT->>MS: Make HTTP calls
    MS->>CT: Return mock responses
    CT->>PB: Publish contract (pact file)

    PT->>PB: Fetch contracts
    PT->>PS: Replay interactions
    PS->>PT: Return real responses
    PT->>PT: Verify against expectations
    PT->>PB: Publish verification results
```
Figure: Pact workflow from consumer test to provider verification.

### Consumer Side: Writing Pact Tests

Provide practical consumer-side test examples.

```typescript title="consumer-pact-test.ts"
import { PactV3, MatchersV3 } from '@pact-foundation/pact';

const { like, eachLike, regex, datetime } = MatchersV3;

const provider = new PactV3({
  consumer: 'OrderService',
  provider: 'UserService',
  logLevel: 'warn',
});

describe('User Service Contract', () => {
  describe('GET /users/:id', () => {
    it('returns user details for valid user ID', async () => {
      // Define the expected interaction
      await provider
        .given('a user with ID 123 exists')
        .uponReceiving('a request for user 123')
        .withRequest({
          method: 'GET',
          path: '/users/123',
          headers: {
            Authorization: like('Bearer token'),
            Accept: 'application/json',
          },
        })
        .willRespondWith({
          status: 200,
          headers: {
            'Content-Type': 'application/json',
          },
          body: {
            userId: like('123'),
            email: regex(/^[\w.-]+@[\w.-]+\.\w+$/, 'user@example.com'),
            name: like('John Doe'),
            createdAt: datetime("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"),
            roles: eachLike('admin'),
          },
        });

      // Execute the test
      await provider.executeTest(async (mockServer) => {
        const client = new UserServiceClient(mockServer.url);
        const user = await client.getUser('123');

        expect(user.userId).toBeDefined();
        expect(user.email).toContain('@');
        expect(user.roles).toBeInstanceOf(Array);
      });
    });

    it('returns 404 for non-existent user', async () => {
      await provider
        .given('no user with ID 999 exists')
        .uponReceiving('a request for non-existent user')
        .withRequest({
          method: 'GET',
          path: '/users/999',
          headers: {
            Authorization: like('Bearer token'),
          },
        })
        .willRespondWith({
          status: 404,
          body: {
            error: like('User not found'),
            code: like('USER_NOT_FOUND'),
          },
        });

      await provider.executeTest(async (mockServer) => {
        const client = new UserServiceClient(mockServer.url);
        await expect(client.getUser('999')).rejects.toThrow('User not found');
      });
    });
  });
});
```
Code: Consumer-side Pact test with matchers for flexible verification.

### Understanding Pact Matchers

Detail the matcher system that makes contracts flexible.

```typescript title="pact-matchers.ts"
import { MatchersV3 } from '@pact-foundation/pact';

const {
  like,           // Type matching
  eachLike,       // Array with type matching
  regex,          // Regex pattern matching
  datetime,       // DateTime format matching
  integer,        // Integer type
  decimal,        // Decimal type
  boolean,        // Boolean type
  string,         // String type
  nullValue,      // Null value
  uuid,           // UUID format
  email,          // Email format
  ipv4Address,    // IPv4 format
} = MatchersV3;

// Examples
const matcherExamples = {
  // like(): Match type, use example for mock
  userId: like('abc-123'),
  // Contract: must be a string
  // Mock returns: 'abc-123'

  // eachLike(): Array where each item matches type
  items: eachLike({
    id: like('item-1'),
    price: decimal(19.99),
  }),
  // Contract: array of objects with id (string) and price (decimal)
  // Mock returns: [{ id: 'item-1', price: 19.99 }]

  // regex(): Match against pattern
  status: regex(/^(pending|completed|failed)$/, 'pending'),
  // Contract: must match regex
  // Mock returns: 'pending'

  // Nested matching
  metadata: like({
    createdAt: datetime("yyyy-MM-dd'T'HH:mm:ss'Z'"),
    updatedBy: like('user-123'),
    tags: eachLike('important'),
  }),
};
```
Code: Pact matchers for flexible contract definitions.

| Matcher | Use Case | Contract Meaning |
|---------|----------|------------------|
| `like(example)` | Most fields | Same type as example |
| `eachLike(example)` | Arrays | Array with items of same type |
| `regex(pattern, example)` | Enums, formats | Must match regex |
| `datetime(format)` | Timestamps | Valid datetime in format |
| `integer(example)` | Counts, IDs | Integer number |
| `decimal(example)` | Prices, rates | Decimal number |
| `uuid()` | Identifiers | Valid UUID format |

Table: Common Pact matchers and their use cases.

<Callout type="info">
Matchers are the key to maintainable contracts. Use `like()` for most fields—it verifies structure without coupling to specific values.
</Callout>

### Provider Side: Verification

Show how providers verify contracts.

```typescript title="provider-pact-test.ts"
import { Verifier } from '@pact-foundation/pact';
import { app } from '../src/app';

describe('User Service Provider Verification', () => {
  let server: Server;

  beforeAll(async () => {
    server = app.listen(3001);
  });

  afterAll(async () => {
    server.close();
  });

  it('validates the expectations of OrderService', async () => {
    const verifier = new Verifier({
      provider: 'UserService',
      providerBaseUrl: 'http://localhost:3001',

      // Pact Broker configuration
      pactBrokerUrl: process.env.PACT_BROKER_URL,
      pactBrokerToken: process.env.PACT_BROKER_TOKEN,

      // Or local pact files
      // pactUrls: ['./pacts/orderservice-userservice.json'],

      // Provider states setup
      stateHandlers: {
        'a user with ID 123 exists': async () => {
          await seedDatabase({
            users: [{ id: '123', email: 'user@example.com', name: 'John Doe' }],
          });
        },
        'no user with ID 999 exists': async () => {
          await clearDatabase();
        },
      },

      // Publish results
      publishVerificationResult: true,
      providerVersion: process.env.GIT_COMMIT_SHA,
      providerVersionBranch: process.env.GIT_BRANCH,
    });

    await verifier.verifyProvider();
  });
});
```
Code: Provider-side Pact verification with state handlers.

### Provider States

Explain how to handle test data setup.

```typescript title="provider-states.ts"
// Provider states let consumers specify preconditions
// without knowing implementation details

const stateHandlers: StateHandlers = {
  // Simple state
  'a user exists': async () => {
    await db.users.create({ id: 'test-user', email: 'test@example.com' });
  },

  // Parameterized state
  'a user with ID {id} exists': async (params) => {
    await db.users.create({
      id: params.id,
      email: `user-${params.id}@example.com`,
    });
  },

  // State with cleanup
  'the system has no users': async () => {
    await db.users.deleteAll();
    return () => {
      // Teardown function (optional)
      console.log('Cleaned up empty state');
    };
  },

  // Complex state
  'user {userId} has {count} orders': async (params) => {
    const user = await db.users.create({ id: params.userId });
    for (let i = 0; i < params.count; i++) {
      await db.orders.create({ userId: user.id, orderId: `order-${i}` });
    }
  },
};
```
Code: Provider state handlers for test data setup.

<Callout type="warning">
Provider states should be minimal—just enough to satisfy the contract. Don't build elaborate fixtures; contract tests verify structure, not business logic.
</Callout>

## Schema-Based Alternatives

### OpenAPI-Based Contract Testing

Compare Pact with schema-based approaches.

```yaml title="openapi-contract-testing.yaml"
approaches:
  pact:
    type: "Consumer-driven"
    contract_source: "Consumer tests"
    strengths:
      - "Tests actual consumer needs"
      - "Fine-grained matchers"
      - "Built-in broker"
    weaknesses:
      - "Requires buy-in from all teams"
      - "Learning curve"

  openapi_tools:
    type: "Schema-driven"
    contract_source: "OpenAPI specification"
    tools:
      - "Prism (Stoplight)"
      - "Dredd"
      - "Schemathesis"
    strengths:
      - "Uses existing specs"
      - "Simpler mental model"
    weaknesses:
      - "Specs drift from reality"
      - "Tests provider, not consumer needs"

  graphql_schema:
    type: "Schema-driven"
    contract_source: "GraphQL schema"
    tools:
      - "Apollo Studio"
      - "GraphQL Inspector"
    strengths:
      - "Schema is the contract"
      - "Breaking change detection"
    weaknesses:
      - "GraphQL-specific"
```
Code: Comparison of contract testing approaches.

### When to Use Each Approach

```mermaid
graph TD
    A[Need Contract Testing?] --> B{Many Consumers?}

    B -->|Yes| C{Consumers Known?}
    B -->|No| D[Schema-based may suffice]

    C -->|Yes, Internal| E[Pact CDC]
    C -->|No, Public API| F[Schema + Versioning]

    D --> G{Existing OpenAPI?}
    G -->|Yes| H[Prism/Dredd]
    G -->|No| I[Consider Pact anyway]

    E --> J[Full Pact workflow]
    F --> K[OpenAPI + semver]
```
Figure: Decision tree for choosing contract testing approach.

| Scenario | Recommended Approach |
|----------|---------------------|
| Internal microservices, known consumers | Pact CDC |
| Public API, unknown consumers | OpenAPI + semantic versioning |
| GraphQL API | GraphQL schema + Apollo Studio |
| Small team, few services | Pact or schema-based both work |
| Large org, many teams | Pact with Pact Broker |
| Legacy API, can't change provider | Schema-based validation only |

Table: Contract testing approach by scenario.

## CI/CD Integration

### Pact Broker Setup

Explain how to set up the Pact Broker for centralized contract management.

```yaml title="docker-compose-pact-broker.yaml"
version: '3'
services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_USER: pact
      POSTGRES_PASSWORD: pact
      POSTGRES_DB: pact
    volumes:
      - pact-db:/var/lib/postgresql/data

  pact-broker:
    image: pactfoundation/pact-broker:latest
    ports:
      - "9292:9292"
    environment:
      PACT_BROKER_DATABASE_URL: "postgres://pact:pact@postgres/pact"
      PACT_BROKER_BASIC_AUTH_USERNAME: admin
      PACT_BROKER_BASIC_AUTH_PASSWORD: admin
      PACT_BROKER_ALLOW_PUBLIC_READ: "true"
    depends_on:
      - postgres

volumes:
  pact-db:
```
Code: Docker Compose setup for Pact Broker.

### Consumer CI Pipeline

```yaml title="consumer-ci.yaml"
# .github/workflows/consumer-ci.yaml
name: Consumer CI

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Run unit tests
        run: npm test

      - name: Run contract tests
        run: npm run test:contract
        env:
          PACT_BROKER_URL: ${{ secrets.PACT_BROKER_URL }}
          PACT_BROKER_TOKEN: ${{ secrets.PACT_BROKER_TOKEN }}

      - name: Publish contracts
        if: github.ref == 'refs/heads/main'
        run: |
          npx pact-broker publish ./pacts \
            --consumer-app-version=${{ github.sha }} \
            --branch=${{ github.ref_name }} \
            --broker-base-url=${{ secrets.PACT_BROKER_URL }} \
            --broker-token=${{ secrets.PACT_BROKER_TOKEN }}

      - name: Can I Deploy?
        run: |
          npx pact-broker can-i-deploy \
            --pacticipant=OrderService \
            --version=${{ github.sha }} \
            --to-environment=production \
            --broker-base-url=${{ secrets.PACT_BROKER_URL }} \
            --broker-token=${{ secrets.PACT_BROKER_TOKEN }}
```
Code: Consumer CI pipeline with contract publishing.

### Provider CI Pipeline

```yaml title="provider-ci.yaml"
# .github/workflows/provider-ci.yaml
name: Provider CI

on:
  push:
  pull_request:
  # Webhook from Pact Broker when new contracts published
  repository_dispatch:
    types: [pact-contract-published]

jobs:
  verify:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Run unit tests
        run: npm test

      - name: Verify contracts
        run: npm run test:contract:verify
        env:
          PACT_BROKER_URL: ${{ secrets.PACT_BROKER_URL }}
          PACT_BROKER_TOKEN: ${{ secrets.PACT_BROKER_TOKEN }}
          GIT_COMMIT_SHA: ${{ github.sha }}
          GIT_BRANCH: ${{ github.ref_name }}

      - name: Can I Deploy?
        run: |
          npx pact-broker can-i-deploy \
            --pacticipant=UserService \
            --version=${{ github.sha }} \
            --to-environment=production \
            --broker-base-url=${{ secrets.PACT_BROKER_URL }} \
            --broker-token=${{ secrets.PACT_BROKER_TOKEN }}
```
Code: Provider CI pipeline with contract verification.

<Callout type="success">
The `can-i-deploy` command is the key to safe deployments. It checks if the current version is compatible with all services in the target environment before allowing deployment.
</Callout>

### The Can-I-Deploy Flow

```mermaid
sequenceDiagram
    participant Dev as Developer
    participant CI as CI Pipeline
    participant PB as Pact Broker
    participant Prod as Production

    Dev->>CI: Push code
    CI->>CI: Run tests
    CI->>PB: Publish contract/verification
    CI->>PB: can-i-deploy?

    alt Compatible
        PB->>CI: ✅ Safe to deploy
        CI->>Prod: Deploy
        CI->>PB: Record deployment
    else Incompatible
        PB->>CI: ❌ Breaking change detected
        CI->>Dev: Fail build with details
    end
```
Figure: Can-I-Deploy flow preventing incompatible deployments.

## Test Organization

### Structuring Contract Tests

Provide guidance on organizing contract test files.

```text
Project Structure:

consumer-service/
├── src/
│   └── clients/
│       └── user-service-client.ts
├── test/
│   ├── unit/
│   │   └── ...
│   └── contract/
│       ├── pact.setup.ts           # Shared Pact configuration
│       ├── user-service.pact.ts    # Contracts for UserService
│       └── order-service.pact.ts   # Contracts for OrderService
├── pacts/                          # Generated pact files (gitignored)
│   └── consumerservice-userservice.json
└── pact.config.js                  # Pact configuration

provider-service/
├── src/
│   └── ...
├── test/
│   ├── unit/
│   │   └── ...
│   └── contract/
│       ├── provider-states.ts      # State handlers
│       └── provider-verification.ts # Verification tests
└── pact.config.js
```

```typescript title="pact-setup.ts"
// test/contract/pact.setup.ts
import { PactV3 } from '@pact-foundation/pact';
import { resolve } from 'path';

export function createPactProvider(providerName: string): PactV3 {
  return new PactV3({
    consumer: process.env.PACT_CONSUMER || 'OrderService',
    provider: providerName,
    dir: resolve(__dirname, '../../pacts'),
    logLevel: process.env.PACT_LOG_LEVEL || 'warn',
  });
}

// Shared matchers for consistency
export const commonMatchers = {
  timestamp: () => datetime("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"),
  uuid: () => regex(
    /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/,
    'a1b2c3d4-e5f6-7890-abcd-ef1234567890'
  ),
  email: () => regex(
    /^[\w.-]+@[\w.-]+\.\w+$/,
    'user@example.com'
  ),
};
```
Code: Shared Pact configuration and matchers.

### Keeping Tests Maintainable

```yaml title="maintainability-guidelines.yaml"
guidelines:
  one_interaction_per_test:
    description: "Each test should verify one API interaction"
    reason: "Easier to debug, clearer failure messages"

  use_matchers_not_literals:
    description: "Prefer like('example') over exact values"
    reason: "Contracts verify structure, not specific data"

  minimal_provider_states:
    description: "State handlers should do minimal setup"
    reason: "Contract tests aren't integration tests"

  share_common_patterns:
    description: "Extract common matchers and setup"
    reason: "Consistency across contracts"

  version_contracts_with_code:
    description: "Contracts should be in same repo as consumer"
    reason: "Contract changes = code changes"

  review_generated_pacts:
    description: "Occasionally review the JSON pact files"
    reason: "Catch overly specific or missing matchers"
```
Code: Guidelines for maintainable contract tests.

<Callout type="warning">
Contract test suites grow with your service dependencies. Without organization, you'll end up with hundreds of similar tests. Extract patterns, use shared setup, and review periodically for redundancy.
</Callout>

## Common Pitfalls

### Testing Too Much

```typescript title="over-specified-contract.ts"
// ❌ BAD: Over-specified contract
await provider
  .uponReceiving('get user')
  .withRequest({
    method: 'GET',
    path: '/users/123',
  })
  .willRespondWith({
    status: 200,
    body: {
      userId: '123',                    // Exact value!
      email: 'john@example.com',        // Exact value!
      name: 'John Doe',                 // Exact value!
      createdAt: '2024-01-15T10:30:00Z', // Exact value!
    },
  });
// This test is brittle - any data change breaks it

// ✅ GOOD: Properly specified contract
await provider
  .uponReceiving('get user')
  .withRequest({
    method: 'GET',
    path: regex(/^\/users\/\d+$/, '/users/123'),
  })
  .willRespondWith({
    status: 200,
    body: {
      userId: like('123'),
      email: regex(/^[\w.-]+@[\w.-]+\.\w+$/, 'john@example.com'),
      name: like('John Doe'),
      createdAt: datetime("yyyy-MM-dd'T'HH:mm:ss'Z'"),
    },
  });
// This test verifies structure, not specific data
```
Code: Over-specified vs properly specified contracts.

### Missing Error Cases

```typescript title="error-case-contracts.ts"
// Don't just test happy paths!
// Consumers depend on error response shapes too

describe('Error contracts', () => {
  it('handles 400 Bad Request', async () => {
    await provider
      .given('invalid request data')
      .uponReceiving('a request with invalid data')
      .withRequest({
        method: 'POST',
        path: '/users',
        body: { email: 'not-an-email' },
      })
      .willRespondWith({
        status: 400,
        body: {
          error: like('Validation failed'),
          details: eachLike({
            field: like('email'),
            message: like('Invalid email format'),
          }),
        },
      });
  });

  it('handles 401 Unauthorized', async () => {
    await provider
      .given('no authentication')
      .uponReceiving('a request without auth token')
      .withRequest({
        method: 'GET',
        path: '/users/123',
        // No Authorization header
      })
      .willRespondWith({
        status: 401,
        body: {
          error: like('Authentication required'),
          code: like('UNAUTHORIZED'),
        },
      });
  });
});
```
Code: Contract tests for error responses.

### Provider State Complexity

```yaml title="state-complexity-pitfalls.yaml"
# ❌ BAD: Complex state that mirrors production data
states:
  - name: "production-like database with 1000 users"
    problem: "Slow, brittle, not what contract tests are for"

  - name: "user 123 with orders 456, 789 and payment method ending 4242"
    problem: "Too specific, couples consumer to provider data model"

# ✅ GOOD: Minimal states that satisfy the contract
states:
  - name: "a user exists"
    implementation: "Create one user with auto-generated data"

  - name: "user has orders"
    implementation: "Create user with 2 generic orders"

  - name: "unauthorized"
    implementation: "No setup needed, just don't auth"
```
Code: Provider state complexity pitfalls.

## Scaling Contract Testing

### Managing Many Contracts

```mermaid
graph TD
    subgraph Consumers
        C1[Order Service]
        C2[Shipping Service]
        C3[Analytics Service]
        C4[Mobile App]
    end

    subgraph Pact Broker
        PB[Contract Registry]
    end

    subgraph Providers
        P1[User Service]
        P2[Product Service]
        P3[Payment Service]
    end

    C1 --> PB
    C2 --> PB
    C3 --> PB
    C4 --> PB

    PB --> P1
    PB --> P2
    PB --> P3
```
Figure: Contract testing at scale with Pact Broker as central registry.

```yaml title="scaling-strategies.yaml"
strategies:
  environment_management:
    description: "Track which versions are in which environment"
    implementation: |
      pact-broker record-deployment \
        --pacticipant=UserService \
        --version=$GIT_SHA \
        --environment=production

  webhook_triggers:
    description: "Auto-trigger provider verification on new contracts"
    implementation: "Configure Pact Broker webhooks to trigger provider CI"

  pending_pacts:
    description: "Don't fail provider builds for new, unverified contracts"
    implementation: "enablePending: true in provider verification"

  wip_pacts:
    description: "Include work-in-progress contracts in verification"
    implementation: "includeWipPactsSince: '2024-01-01'"

  matrix_view:
    description: "Visualize compatibility across all services"
    tool: "Pact Broker web UI"
```
Code: Strategies for scaling contract testing.

<Callout type="info">
Pending pacts prevent the "chicken and egg" problem: new consumers can publish contracts without breaking provider builds, while providers gradually add support.
</Callout>

## Conclusion

Summarize the key points: consumer-driven contracts catch breaking API changes before deployment; Pact provides a mature, well-tooled solution for CDC; the `can-i-deploy` command is the key to safe deployments; and contract tests should verify structure, not business logic. Emphasize that contract testing is an investment that pays off as services multiply—the coordination overhead of integration testing grows quadratically, while contract testing grows linearly.

<Callout type="success">
Contract tests are fast, reliable, and catch breaking changes at PR time. They don't replace integration tests entirely, but they eliminate the majority of "works on my machine, breaks in production" API compatibility issues.
</Callout>

---

## Cover Prompt

### Prompt 1: The Handshake Agreement

Create an image of two robotic hands performing a handshake, with a glowing contract document floating between them. The contract has checkmarks and verification seals. Digital streams of data flow between the hands. Style: futuristic business agreement, blue and teal tones, clean geometric design, 16:9 aspect ratio.

### Prompt 2: The Puzzle Pieces

Design an image showing API puzzle pieces from different services clicking together perfectly. Each piece has an endpoint label (/users, /orders, /payments). A magnifying glass inspects the connection points, showing green checkmarks where they fit. Style: colorful technical illustration, satisfying fit visualization, clean lines, 16:9 aspect ratio.

### Prompt 3: The Safety Net

Illustrate a trapeze artist (representing code deployment) with a safety net below made of interwoven contract documents. The net is labeled with consumer names. The artist performs confidently knowing the net will catch breaking changes. Style: circus safety metaphor, dramatic lighting, warm and cool color contrast, 16:9 aspect ratio.

### Prompt 4: The Blueprint Verification

Create an image of an architect comparing a building under construction against blueprints. The blueprints represent the contract, the building represents the provider implementation. Green checkmarks appear where they match. Style: architectural comparison, technical blueprint aesthetic, clean professional look, 16:9 aspect ratio.

### Prompt 5: The Two-Way Mirror

Design an image showing a consumer service on one side of a two-way mirror and a provider service on the other. Between them, a contract document glows, showing what each side expects from the other. Both sides see their view clearly. Style: split-screen technology visualization, symmetric composition, purple and blue gradient, 16:9 aspect ratio.
