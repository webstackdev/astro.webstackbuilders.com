---
title: "Gitops Description"
description: "Gitops Description"
cover: "./cover.png"
coverAlt: "TODO"
author: "kevin-brown"
publishDate: 2024-01-15
tags: ["apis-and-gateways"]
featured: true
---

In 2026, separating application code from infrastructure as code (IaC) is standard operational hygiene for ensuring security, governance, and stable automation.

1. What's in the Infrastructure Config Repo?

This repository (often called a "GitOps repo") contains the declarative state of your environment. It typically includes:

- Infrastructure Definitions: Terraform files, OpenTofu modules, or Crossplane compositions that provision the "hardware" (VPC, databases, clusters).
- Kubernetes Manifests: Helm charts, Kustomize overlays, or raw YAML that define how the app runs (CPU/memory limits, ingress rules, environment variables).
- Environment Overlays: Specific folders for dev, staging, and prod to manage differences between environments without duplicating code.
- Policy-as-Code: Rules (e.g., OPA/Rego) that enforce security standards, such as "no public S3 buckets".

2. Changes to Your Application Repo

Your application repo remains the home for feature development, but its CD portion changes significantly:

- CI Stage (Stays Mostly Same): Continues to handle builds, linting, vulnerability scans, and unit/E2E tests.
- CD Stage (Changes): Instead of "pushing" a deployment to Vercel or a cluster, the final step in the application pipeline is now to update the GitOps repo.
- It builds the container image and pushes it to a registry.
- It then creates a Pull Request or directly commits to the Infrastructure Repo, updating the image tag in the manifests (e.g., changing image: v1.0 to image: v1.1).

3. CI/CD in the Infrastructure Repo

The infrastructure repo has its own dedicated lifecycle to ensure changes don't "break the world":

Infra CI Stage:

- Linting/Validation: Tools like tflint or kube-linter check for syntax errors.
- Security Scans: Scanners like tfsec or Checkov search for misconfigurations.
- Dry Runs: Generates a "Plan" (e.g., terraform plan) to show exactly what will be changed before it happens.

Infra CD Stage:

In a GitOps model, there is no traditional "push" CD. Instead, a GitOps Controller (like Argo CD or Flux) inside the cluster watches this repo. The moment it sees a new commit (like the image tag update from your app repo), it pulls and applies those changes to the cluster automatically.

Why this separation?

Security: Developers can have full access to app code but restricted access to production infrastructure.
Stability: Infrastructure changes (like scaling a DB) can be tested and audited separately from code changes (like fixing a typo).

## Typical GitOps Repository Structure (2026)

A production-grade GitOps repository uses a "Base and Overlays" pattern (often with Kustomize or Helm)

```bash
gitops-repo/
├── infrastructure/               # Shared infra-level resources
│   ├── base/                     # Core definitions
│   │   ├── networking.yaml       # VPC/Subnet definitions (Crossplane/Terraform)
│   │   └── database.yaml         # RDS/DB instances
│   └── overlays/                 # Environment-specific tweaks
│       ├── dev/
│       └── prod/                 # e.g., larger DB instance for prod
├── apps/                         # Application manifests
│   ├── my-web-app/
│   │   ├── base/
│   │   │   ├── deployment.yaml   # Basic pod/container spec
│   │   │   └── service.yaml
│   │   └── overlays/
│   │       ├── staging/          # deployment-patch.yaml (low replicas)
│   │       └── production/       # deployment-patch.yaml (high replicas)
├── policies/                     # Policy as Code (PaC)
│   ├── security-rules.rego       # OPA policies (e.g., "no root containers")
│   └── resource-limits.yaml      # Kyverno or Gatekeeper rules
└── clusters/                     # Root entry points for GitOps controller
    ├── staging-cluster/
    │   └── kustomization.yaml    # Points to apps/my-web-app/overlays/staging
    └── prod-cluster/
        └── kustomization.yaml    # Points to apps/my-web-app/overlays/production

```

Immutable Tags: In 2026, standard practice is to use unique, immutable tags—typically the Git Commit SHA (e.g., my-app:a3f5b2c).

OPA, Kyverno, and Gatekeeper

- OPA (Open Policy Agent): An open-source, general-purpose policy engine that unifies policy enforcement across the stack. It uses a declarative language called Rego to define complex rules.
- Gatekeeper: A specialized project that integrates OPA into Kubernetes. It acts as a validating admission controller, intercepting requests to the Kubernetes API and checking them against OPA policies before resources are created or modified.
- Kyverno: A Kubernetes-native policy engine. Unlike Gatekeeper, it does not require learning Rego; policies are written in standard YAML. It can validate, mutate (modify), and generate resources, as well as verify container image signatures.
