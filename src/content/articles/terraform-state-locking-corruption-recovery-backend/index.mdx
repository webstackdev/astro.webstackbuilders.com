---
title: "Terraform State: Failure Modes and Recovery"
description: "State locking, backend configuration, and recovery strategies for when state corruption happens."
cover: "./cover.jpg"
coverAlt: "TODO"
author: "kevin-brown"
publishDate: 2024-01-15
tags: ["cloud-platforms"]
featured: true
---

*[API]: Application Programming Interface
*[ARN]: Amazon Resource Name
*[CI]: Continuous Integration
*[DynamoDB]: Amazon DynamoDB
*[GCS]: Google Cloud Storage
*[HCL]: HashiCorp Configuration Language
*[IAM]: Identity and Access Management
*[IaC]: Infrastructure as Code
*[KMS]: Key Management Service
*[S3]: Amazon Simple Storage Service

State file anatomy, locking race conditions, backend selection, and the recovery procedures you need before disaster strikes.

State corruption is a when, not an if.

## Understanding Terraform State

State is Terraform's memory—it tracks what exists, what you declared, and how they map together.

### State File Anatomy

What lives inside the state file and why it matters.

```json
{
  "version": 4,
  "terraform_version": "1.6.0",
  "serial": 42,
  "lineage": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "outputs": {
    "vpc_id": {
      "value": "vpc-0123456789abcdef0",
      "type": "string"
    }
  },
  "resources": [
    {
      "mode": "managed",
      "type": "aws_vpc",
      "name": "main",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "id": "vpc-0123456789abcdef0",
            "cidr_block": "10.0.0.0/16",
            "enable_dns_hostnames": true,
            "tags": {
              "Name": "production-vpc",
              "Environment": "production"
            }
          },
          "private": "eyJzY2hlbWFfdmVyc2lvbiI6IjEifQ=="
        }
      ]
    }
  ]
}
```

```typescript
// State file critical fields
interface TerraformState {
  version: number           // State format version (currently 4)
  terraform_version: string // Terraform version that wrote state
  serial: number            // Incremented on every state change
  lineage: string           // Unique ID for this state's history
  outputs: Record<string, OutputValue>
  resources: ResourceState[]
}

interface ResourceState {
  mode: 'managed' | 'data'
  type: string              // Resource type (aws_vpc, google_compute_instance)
  name: string              // Resource name from config
  provider: string          // Provider that manages this resource
  instances: InstanceState[]
}

interface InstanceState {
  schema_version: number    // Provider's schema version
  attributes: Record<string, unknown>  // All resource attributes
  private: string           // Base64 encoded provider metadata
  dependencies?: string[]   // Explicit dependencies

  // For resources with count/for_each
  index_key?: string | number
}
```

```
Mermaid diagram: State file role in Terraform workflow.
terraform plan
     │
     ▼
┌─────────────────────────────────────────┐
│         State File                       │
│  "What currently exists"                │
│                                         │
│  vpc-123 → aws_vpc.main                 │
│  subnet-456 → aws_subnet.private[0]    │
│  subnet-789 → aws_subnet.private[1]    │
└─────────────────────────────────────────┘
     │                    ▲
     │                    │
     ▼                    │
┌─────────────┐    ┌─────────────────────┐
│ Config Files │    │   Cloud Provider    │
│ "What should │    │  "What actually     │
│  exist"      │    │   exists"           │
└─────────────┘    └─────────────────────┘
     │                    │
     └────────┬───────────┘
              ▼
        Diff/Plan
     "What needs to change"
```

### Why State Exists

The problems state solves and the problems it creates.

| Purpose | How State Helps | What Can Go Wrong |
|---------|-----------------|-------------------|
| Resource mapping | Maps config names to cloud IDs | Mapping lost = orphaned resources |
| Dependency order | Tracks implicit dependencies | Corrupted deps = wrong order |
| Performance | Caches attributes, avoids API calls | Stale cache = drift detection fails |
| Collaboration | Shared state enables team workflows | Concurrent writes = corruption |
| Drift detection | Compares state to reality | State-reality mismatch = confusion |

:::warning[State Contains Secrets]
State files contain sensitive data in plaintext: database passwords, API keys, private keys. Treat state as a secret. Encrypt at rest, restrict access, and never commit to version control.
:::

## State Locking Mechanisms

Preventing concurrent modifications from corrupting state.

### How Locking Works

The lock acquisition and release flow.

```
Mermaid diagram: State locking sequence.
User A: terraform apply          User B: terraform apply
     │                                │
     ▼                                │
Acquire Lock ─────────────────────────│
     │                                │
     │  Lock Info:                    │
     │  ID: "a1b2c3d4"               │
     │  Who: "user-a@ci"             ▼
     │  Created: "2024-01-15T..."    Acquire Lock
     │                                │
     │                                ▼
     │                          LOCK DENIED
     │                          Error: Lock held by user-a@ci
     │                          Lock ID: a1b2c3d4
     │                                │
     ▼                                │
Apply Changes                         │
     │                                │
     ▼                                │
Write State                           │
     │                                │
     ▼                                │
Release Lock ─────────────────────────│
     │                                ▼
     │                          Retry → Acquire Lock
     │                                │
     │                                ▼
     │                          Apply Changes
```

### S3 + DynamoDB Backend

The standard AWS state backend with locking.

```hcl
# Backend configuration with locking
terraform {
  backend "s3" {
    bucket         = "mycompany-terraform-state"
    key            = "production/infrastructure/terraform.tfstate"
    region         = "us-east-1"

    # Locking via DynamoDB
    dynamodb_table = "terraform-state-locks"

    # Encryption
    encrypt        = true
    kms_key_id     = "alias/terraform-state"

    # Access control
    acl            = "private"
  }
}

# DynamoDB table for locks (create separately or via bootstrap)
resource "aws_dynamodb_table" "terraform_locks" {
  name         = "terraform-state-locks"
  billing_mode = "PAY_PER_REQUEST"
  hash_key     = "LockID"

  attribute {
    name = "LockID"
    type = "S"
  }

  # Enable point-in-time recovery for lock table
  point_in_time_recovery {
    enabled = true
  }

  tags = {
    Purpose = "Terraform state locking"
  }
}
```

```typescript
// DynamoDB lock record structure
interface DynamoDBLockRecord {
  LockID: string     // State file path: "mycompany-terraform-state/prod/terraform.tfstate"
  Info: string       // JSON with lock details
}

interface LockInfo {
  ID: string         // Unique lock ID
  Operation: string  // "OperationTypeApply", "OperationTypePlan"
  Info: string       // Additional context
  Who: string        // User/identity holding lock
  Version: string    // Terraform version
  Created: string    // ISO timestamp
  Path: string       // State file path
}

// Example lock record
const lockExample: DynamoDBLockRecord = {
  LockID: "mycompany-terraform-state/prod/terraform.tfstate-md5",
  Info: JSON.stringify({
    ID: "550e8400-e29b-41d4-a716-446655440000",
    Operation: "OperationTypeApply",
    Info: "",
    Who: "user@example.com",
    Version: "1.6.0",
    Created: "2024-01-15T10:30:00Z",
    Path: "prod/terraform.tfstate"
  })
}
```

### Other Backend Locking Implementations

How different backends handle locking.

```hcl
# Azure Blob Storage with native locking
terraform {
  backend "azurerm" {
    resource_group_name  = "terraform-state-rg"
    storage_account_name = "tfstateaccount"
    container_name       = "tfstate"
    key                  = "prod.terraform.tfstate"

    # Uses Azure Blob leases for locking (automatic)
  }
}

# Google Cloud Storage with locking
terraform {
  backend "gcs" {
    bucket = "mycompany-terraform-state"
    prefix = "terraform/state"

    # GCS uses object generation numbers for locking
    # No separate lock resource needed
  }
}

# PostgreSQL backend (self-hosted)
terraform {
  backend "pg" {
    conn_str    = "postgres://user:pass@host/terraform_state"
    schema_name = "production"

    # Uses PostgreSQL advisory locks
  }
}

# Terraform Cloud/Enterprise
terraform {
  cloud {
    organization = "mycompany"

    workspaces {
      name = "production-infrastructure"
    }

    # Locking is automatic and integrated with runs
  }
}
```

| Backend | Lock Mechanism | Lock Timeout | Force Unlock |
|---------|---------------|--------------|--------------|
| S3 + DynamoDB | DynamoDB conditional writes | Infinite (until released) | `terraform force-unlock` |
| Azure Blob | Blob lease | 60 seconds (renewable) | Break lease via Azure CLI |
| GCS | Object generation | None (optimistic) | Delete lock object |
| PostgreSQL | Advisory locks | Session-based | Kill session |
| Terraform Cloud | Built-in | Run timeout | Cancel run in UI |

## State Corruption Scenarios

What goes wrong and how to recognize it.

### Common Corruption Causes

How state gets into a bad state.

```typescript
// State corruption scenarios
interface CorruptionScenario {
  cause: string
  symptoms: string[]
  detection: string
  severity: 'low' | 'medium' | 'high' | 'critical'
}

const corruptionScenarios: CorruptionScenario[] = [
  {
    cause: 'Interrupted apply (Ctrl+C, network failure)',
    symptoms: [
      'State shows resource that was never created',
      'Resource exists but state shows different attributes',
      'Partial resource creation (some sub-resources missing)'
    ],
    detection: 'terraform plan shows unexpected changes',
    severity: 'medium'
  },
  {
    cause: 'Concurrent state modifications (race condition)',
    symptoms: [
      'Lost updates - changes from one apply missing',
      'Duplicate resources in state',
      'Serial number conflicts'
    ],
    detection: 'Error during plan: "state serial mismatch"',
    severity: 'high'
  },
  {
    cause: 'Manual state editing mistakes',
    symptoms: [
      'Invalid JSON syntax',
      'Missing required fields',
      'Wrong resource types or providers'
    ],
    detection: 'terraform plan fails with parse error',
    severity: 'high'
  },
  {
    cause: 'Provider version mismatch',
    symptoms: [
      'Schema version incompatibility',
      'Missing attributes after provider upgrade',
      'Unexpected resource replacement planned'
    ],
    detection: 'Warnings about schema version during plan',
    severity: 'medium'
  },
  {
    cause: 'State and reality divergence (external changes)',
    symptoms: [
      'terraform plan shows changes you did not make',
      'Resources deleted outside Terraform',
      'Attributes modified in console'
    ],
    detection: 'Drift in terraform plan',
    severity: 'low'
  },
  {
    cause: 'Backend migration failure',
    symptoms: [
      'State exists in old and new backend',
      'Partial state in new backend',
      'Lock orphaned in old backend'
    ],
    detection: 'Resources appear to not exist after migration',
    severity: 'critical'
  }
]
```

### Detecting State Issues

Commands and techniques for diagnosing problems.

```bash
# Validate state file syntax
terraform validate

# Show current state (human readable)
terraform show

# List all resources in state
terraform state list

# Show specific resource details
terraform state show aws_vpc.main

# Pull remote state to local file for inspection
terraform state pull > state_backup.json

# Check for drift between state and reality
terraform plan -refresh-only

# Verbose output for debugging
TF_LOG=DEBUG terraform plan

# Check state file directly
cat terraform.tfstate | jq '.resources[] | {type, name, instances: .instances | length}'
```

```typescript
// State health check script
async function checkStateHealth(statePath: string): Promise<HealthReport> {
  const state = JSON.parse(await readFile(statePath, 'utf-8'))
  const issues: HealthIssue[] = []

  // Check version compatibility
  if (state.version !== 4) {
    issues.push({
      severity: 'warning',
      message: `State version ${state.version} may need migration`
    })
  }

  // Check for orphaned resources (no instances)
  for (const resource of state.resources) {
    if (resource.instances.length === 0) {
      issues.push({
        severity: 'warning',
        message: `Resource ${resource.type}.${resource.name} has no instances`
      })
    }
  }

  // Check for duplicate resource addresses
  const addresses = state.resources.map(r => `${r.type}.${r.name}`)
  const duplicates = addresses.filter((a, i) => addresses.indexOf(a) !== i)
  if (duplicates.length > 0) {
    issues.push({
      severity: 'critical',
      message: `Duplicate resources: ${duplicates.join(', ')}`
    })
  }

  // Check lineage is valid UUID
  if (!isValidUUID(state.lineage)) {
    issues.push({
      severity: 'critical',
      message: 'Invalid state lineage'
    })
  }

  // Check serial is incrementing (compare with backup)
  // ...

  return {
    healthy: issues.filter(i => i.severity === 'critical').length === 0,
    issues
  }
}
```

:::danger[Never Edit State Manually Unless Absolutely Necessary]
Direct state file editing is error-prone and can cause corruption. Use `terraform state` commands instead: `terraform state mv`, `terraform state rm`, `terraform state import`. Manual editing is a last resort, always with a backup.
:::

## Recovery Procedures

Fixing state when things go wrong.

### Force Unlock Procedure

Releasing stuck locks safely.

```bash
# Check if lock exists and who holds it
terraform plan
# Error: Error acquiring the state lock
# Lock Info:
#   ID:        550e8400-e29b-41d4-a716-446655440000
#   Path:      terraform-state/prod/terraform.tfstate
#   Operation: OperationTypeApply
#   Who:       ci-runner@github-actions
#   Version:   1.6.0
#   Created:   2024-01-15 10:30:00.123456 +0000 UTC

# Verify the lock holder is truly dead (not still running)
# CHECK: Is there a CI job still running?
# CHECK: Is another terminal running terraform?

# If certain the lock is orphaned, force unlock
terraform force-unlock 550e8400-e29b-41d4-a716-446655440000

# For DynamoDB, can also delete directly (emergency only)
aws dynamodb delete-item \
  --table-name terraform-state-locks \
  --key '{"LockID": {"S": "mycompany-terraform-state/prod/terraform.tfstate-md5"}}'
```

### State Refresh and Import

Reconciling state with reality.

```bash
# Refresh state from cloud provider (detect drift)
terraform apply -refresh-only

# If resource exists in cloud but not in state, import it
terraform import aws_vpc.main vpc-0123456789abcdef0

# For complex resources, generate import block
# Terraform 1.5+ import block syntax
cat >> imports.tf << 'EOF'
import {
  to = aws_vpc.main
  id = "vpc-0123456789abcdef0"
}

import {
  to = aws_subnet.private[0]
  id = "subnet-111111111"
}

import {
  to = aws_subnet.private[1]
  id = "subnet-222222222"
}
EOF

# Generate configuration from imports
terraform plan -generate-config-out=generated.tf
```

```hcl
# Terraform 1.5+ import blocks for bulk import
import {
  to = aws_instance.web
  id = "i-0123456789abcdef0"
}

import {
  to = aws_security_group.web
  id = "sg-0123456789abcdef0"
}

# Run plan to verify imports
# terraform plan

# Apply to execute imports
# terraform apply
```

### State Surgery with terraform state Commands

Precise state modifications without full recovery.

```bash
# Remove resource from state (keeps actual resource)
# Use when resource should no longer be managed by Terraform
terraform state rm aws_instance.legacy_server

# Move resource to different address (refactoring)
terraform state mv aws_instance.web aws_instance.application

# Move resource to different state file (splitting modules)
terraform state mv -state-out=other.tfstate aws_vpc.shared

# Move resource between modules
terraform state mv module.old.aws_vpc.main module.new.aws_vpc.main

# Replace provider (e.g., after provider rename)
terraform state replace-provider \
  registry.terraform.io/hashicorp/aws \
  registry.terraform.io/-/aws

# Taint resource to force recreation on next apply
terraform taint aws_instance.problematic

# Untaint if tainting was a mistake
terraform untaint aws_instance.problematic
```

### Full State Recovery from Backup

When state is lost or severely corrupted.

```bash
# Step 1: Get state backup
# Option A: From S3 versioning
aws s3api list-object-versions \
  --bucket mycompany-terraform-state \
  --prefix prod/terraform.tfstate

aws s3api get-object \
  --bucket mycompany-terraform-state \
  --key prod/terraform.tfstate \
  --version-id "abc123version" \
  recovered-state.json

# Option B: From local backup
cp terraform.tfstate.backup terraform.tfstate

# Option C: From CI artifact storage
# Download from your CI system's artifact storage

# Step 2: Validate recovered state
cat recovered-state.json | jq .
terraform show -json recovered-state.json | jq .

# Step 3: Push recovered state to backend
terraform state push recovered-state.json

# Step 4: Verify recovery
terraform plan
# Should show minimal or no changes if recovery successful
```

```
Mermaid diagram: State recovery decision tree.
State Problem Detected
         │
         ▼
    Can you plan?
    ┌────┴────┐
   Yes        No
    │          │
    ▼          ▼
Is it just    Parse error?
drift?        ┌────┴────┐
    │        Yes        No
    ▼         │          │
terraform     ▼          ▼
refresh     Restore    Lock stuck?
            backup      ┌───┴───┐
                       Yes      No
                        │       │
                        ▼       ▼
                    force-   Backend
                    unlock   error?
                               │
                               ▼
                           Check backend
                           permissions
                           and config
```

## Backend Selection and Configuration

Choosing and configuring the right state backend.

### Backend Comparison

Factors to consider when choosing a backend.

| Factor | S3 + DynamoDB | Azure Blob | GCS | Terraform Cloud | PostgreSQL |
|--------|--------------|------------|-----|-----------------|------------|
| Setup complexity | Medium | Low | Low | Very Low | High |
| Locking reliability | High | Medium | Medium | Very High | High |
| Cost | Low | Low | Low | Free tier + paid | Self-managed |
| Encryption | KMS | Built-in | KMS | Built-in | Manual |
| Versioning | S3 versioning | Blob versioning | Object versioning | Built-in | Manual |
| Access control | IAM | Azure AD | IAM | Teams | Database ACL |
| Multi-region | Manual setup | Manual setup | Multi-region buckets | Global | Manual |

### Production-Ready S3 Backend

Complete configuration with all safety features.

```hcl
# State bucket with all protections
resource "aws_s3_bucket" "terraform_state" {
  bucket = "mycompany-terraform-state-${data.aws_caller_identity.current.account_id}"

  # Prevent accidental deletion
  force_destroy = false

  tags = {
    Purpose   = "Terraform state storage"
    ManagedBy = "terraform-bootstrap"
  }
}

# Enable versioning for recovery
resource "aws_s3_bucket_versioning" "terraform_state" {
  bucket = aws_s3_bucket.terraform_state.id
  versioning_configuration {
    status = "Enabled"
  }
}

# Server-side encryption
resource "aws_s3_bucket_server_side_encryption_configuration" "terraform_state" {
  bucket = aws_s3_bucket.terraform_state.id

  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm     = "aws:kms"
      kms_master_key_id = aws_kms_key.terraform_state.arn
    }
    bucket_key_enabled = true
  }
}

# Block all public access
resource "aws_s3_bucket_public_access_block" "terraform_state" {
  bucket = aws_s3_bucket.terraform_state.id

  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}

# Lifecycle rule for version cleanup
resource "aws_s3_bucket_lifecycle_configuration" "terraform_state" {
  bucket = aws_s3_bucket.terraform_state.id

  rule {
    id     = "cleanup-old-versions"
    status = "Enabled"

    noncurrent_version_expiration {
      noncurrent_days = 90
    }

    # Keep at least 5 versions regardless of age
    noncurrent_version_transition {
      noncurrent_days = 30
      storage_class   = "STANDARD_IA"
    }
  }
}

# KMS key for state encryption
resource "aws_kms_key" "terraform_state" {
  description             = "Terraform state encryption"
  deletion_window_in_days = 30
  enable_key_rotation     = true

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid    = "Enable IAM policies"
        Effect = "Allow"
        Principal = {
          AWS = "arn:aws:iam::${data.aws_caller_identity.current.account_id}:root"
        }
        Action   = "kms:*"
        Resource = "*"
      }
    ]
  })
}

# DynamoDB table for locking
resource "aws_dynamodb_table" "terraform_locks" {
  name         = "terraform-state-locks"
  billing_mode = "PAY_PER_REQUEST"
  hash_key     = "LockID"

  attribute {
    name = "LockID"
    type = "S"
  }

  point_in_time_recovery {
    enabled = true
  }

  server_side_encryption {
    enabled = true
  }
}
```

### State File Organization

Structuring state for multi-environment setups.

```hcl
# Pattern 1: Path-based separation
# State path: s3://bucket/env/component/terraform.tfstate

# Production VPC
terraform {
  backend "s3" {
    bucket         = "mycompany-terraform-state"
    key            = "production/networking/terraform.tfstate"
    dynamodb_table = "terraform-state-locks"
  }
}

# Staging VPC
terraform {
  backend "s3" {
    bucket         = "mycompany-terraform-state"
    key            = "staging/networking/terraform.tfstate"
    dynamodb_table = "terraform-state-locks"
  }
}

# Pattern 2: Workspace-based separation
terraform {
  backend "s3" {
    bucket         = "mycompany-terraform-state"
    key            = "networking/terraform.tfstate"
    dynamodb_table = "terraform-state-locks"

    # State file becomes: env:/workspace-name/networking/terraform.tfstate
  }
}

# Usage: terraform workspace select production

# Pattern 3: Account-based separation (landing zone)
# Each AWS account gets its own state bucket
terraform {
  backend "s3" {
    bucket         = "terraform-state-${var.account_id}"
    key            = "infrastructure/terraform.tfstate"
    dynamodb_table = "terraform-state-locks"

    # Different role for each account
    role_arn       = "arn:aws:iam::${var.account_id}:role/TerraformStateAccess"
  }
}
```

```
Mermaid diagram: State organization hierarchy.
mycompany-terraform-state (S3 bucket)
│
├── production/
│   ├── networking/
│   │   └── terraform.tfstate
│   ├── compute/
│   │   └── terraform.tfstate
│   └── database/
│       └── terraform.tfstate
│
├── staging/
│   ├── networking/
│   │   └── terraform.tfstate
│   └── compute/
│       └── terraform.tfstate
│
└── shared/
    ├── dns/
    │   └── terraform.tfstate
    └── iam/
        └── terraform.tfstate

Benefits:
- Clear separation by environment
- Independent state files per component
- Fine-grained access control possible
- Parallel applies across components
```

## Preventive Measures

Avoiding state problems before they occur.

### CI/CD State Safety

Preventing concurrent runs and ensuring safe state operations.

```yaml
# GitHub Actions with state safety
name: Terraform Apply

on:
  push:
    branches: [main]

concurrency:
  group: terraform-${{ github.ref }}
  cancel-in-progress: false  # Don't cancel running applies!

jobs:
  apply:
    runs-on: ubuntu-latest
    environment: production  # Requires approval

    steps:
      - uses: actions/checkout@v4

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Terraform Init
        run: terraform init

      - name: Terraform Plan
        id: plan
        run: terraform plan -out=tfplan -input=false

      - name: Save Plan
        uses: actions/upload-artifact@v4
        with:
          name: tfplan
          path: tfplan
          retention-days: 1

      - name: Terraform Apply
        run: terraform apply -input=false tfplan

      - name: Backup State
        if: always()
        run: |
          terraform state pull > state-backup-${{ github.sha }}.json
          aws s3 cp state-backup-${{ github.sha }}.json \
            s3://terraform-backups/state-backup-${{ github.sha }}.json
```

```typescript
// Pre-apply safety checks
interface SafetyCheck {
  name: string
  check: () => Promise<boolean>
  blocking: boolean
}

const safetyChecks: SafetyCheck[] = [
  {
    name: 'No other CI jobs running',
    check: async () => {
      // Query CI API for running terraform jobs
      const runningJobs = await getRunningTerraformJobs()
      return runningJobs.length === 0
    },
    blocking: true
  },
  {
    name: 'State backup exists',
    check: async () => {
      // Verify recent backup in S3
      const backup = await getLatestStateBackup()
      const ageHours = (Date.now() - backup.timestamp) / 3600000
      return ageHours < 24
    },
    blocking: false
  },
  {
    name: 'Plan matches expected changes',
    check: async () => {
      // Compare plan resource counts to PR description
      const plan = await parseTerraformPlan()
      return plan.changes.destroy === 0 || process.env.ALLOW_DESTROY === 'true'
    },
    blocking: true
  },
  {
    name: 'Lock is available',
    check: async () => {
      // Attempt to acquire advisory lock
      const lockAvailable = await checkLockAvailable()
      return lockAvailable
    },
    blocking: true
  }
]
```

### State Backup Strategy

Automated backups beyond S3 versioning.

```bash
#!/bin/bash
# state-backup.sh - Run via cron or CI

set -euo pipefail

ENVIRONMENTS=("production" "staging")
COMPONENTS=("networking" "compute" "database")
BACKUP_BUCKET="terraform-state-backups"
DATE=$(date +%Y-%m-%d)

for env in "${ENVIRONMENTS[@]}"; do
  for component in "${COMPONENTS[@]}"; do
    STATE_KEY="${env}/${component}/terraform.tfstate"
    BACKUP_KEY="backups/${DATE}/${env}/${component}/terraform.tfstate"

    echo "Backing up ${STATE_KEY}..."

    # Copy from state bucket to backup bucket
    aws s3 cp \
      "s3://terraform-state/${STATE_KEY}" \
      "s3://${BACKUP_BUCKET}/${BACKUP_KEY}"

    # Verify backup integrity
    aws s3api head-object \
      --bucket "${BACKUP_BUCKET}" \
      --key "${BACKUP_KEY}" > /dev/null

    echo "Verified backup: ${BACKUP_KEY}"
  done
done

# Clean up backups older than 30 days
aws s3 rm "s3://${BACKUP_BUCKET}/backups/" \
  --recursive \
  --exclude "*" \
  --include "$(date -d '30 days ago' +%Y-%m-%d)/*"
```

:::success[Test Your Recovery Procedures]
Having backups is not enough—you must verify you can restore from them. Schedule quarterly recovery drills: restore state to a test environment and verify `terraform plan` shows no changes against the real infrastructure.
:::

## Conclusion

Terraform state is simultaneously the system's greatest strength and its most dangerous liability. The state file maps your declared infrastructure to cloud reality, enabling Terraform to calculate precise changes—but when state diverges from reality through corruption, lost locks, or failed applies, that same mechanism can cause unintended destruction. Invest in your backend: use S3 with versioning, DynamoDB locking, and KMS encryption as the baseline; enable point-in-time recovery on your lock table. Prevent concurrent modifications through CI/CD concurrency controls, not just DynamoDB locks—CI can start a job before the previous one acquires the lock. Practice recovery procedures before you need them: force-unlock, state push, import, and state surgery with mv/rm commands should be muscle memory, not panicked documentation searches. Back up state independently of S3 versioning to a separate bucket; when the state bucket itself is compromised, you need backups elsewhere. State corruption will happen eventually—the question is whether you will recover in minutes with practiced procedures or spend days reconstructing state through imports and manual investigation.

---

## Cover Image Prompts

### Prompt 1: Vault Door with Combination Lock
Dramatic photograph of a bank vault door with complex locking mechanism—multiple bolts, combination dial, time lock visible. The protection of critical state data. Heavy, secure, serious.

### Prompt 2: Database Recovery Operation
Photograph of a server room with technicians working on recovery—screens showing data, cables, focused activity. The intensity of state recovery operations. Blue-lit, technical environment.

### Prompt 3: Corrupted File Visualization
Abstract digital art showing a document or file fragmenting or corrupting—clean data on one side dissolving into chaos on the other. The visual representation of state corruption.

### Prompt 4: Lock and Key with Timestamp
Stylized photograph of an antique lock with a key, overlaid with digital timestamp displays. The combination of locking mechanism and temporal nature of state operations.

### Prompt 5: Surgeon Operating with Precision
Medical photograph of surgical instruments during a precise operation—the careful, methodical nature of state surgery. Clean, focused, high-stakes environment.
