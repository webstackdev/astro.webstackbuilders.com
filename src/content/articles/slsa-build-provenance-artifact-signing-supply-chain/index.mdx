---
title: "Build Provenance and Signing: A Practical Baseline"
description: "Supply chain security basics that you can implement without a dedicated security team or expensive tooling."
cover: "./cover.png"
coverAlt: "TODO"
author: "kevin-brown"
publishDate: 2024-01-15
tags: ["build-and-deploy"]
featured: true
---

*[CA]: Certificate Authority
*[CI]: Continuous Integration
*[CD]: Continuous Deployment
*[CVE]: Common Vulnerabilities and Exposures
*[DSSE]: Dead Simple Signing Envelope
*[ECDSA]: Elliptic Curve Digital Signature Algorithm
*[GPG]: GNU Privacy Guard
*[HSM]: Hardware Security Module
*[KMS]: Key Management Service
*[OIDC]: OpenID Connect
*[OCI]: Open Container Initiative
*[SBOM]: Software Bill of Materials
*[SHA]: Secure Hash Algorithm
*[SLSA]: Supply-chain Levels for Software Artifacts
*[TOFU]: Trust On First Use
*[VCS]: Version Control System

SLSA levels, signing strategies, provenance attestation, and the minimum viable supply chain security posture.

Perfect supply chain security is impossible; a baseline is achievable.

## The Supply Chain Attack Surface

Understanding what you're defending against before investing in countermeasures.

### Attack Vectors and Real-World Examples

Supply chain attacks exploit trust—the assumption that code, builds, and artifacts are what they claim to be.

```typescript
// Supply chain attack taxonomy
interface SupplyChainAttack {
  vector: string
  description: string
  realWorldExample: string
  impact: string
}

const attackVectors: SupplyChainAttack[] = [
  {
    vector: 'Source code compromise',
    description: 'Attacker gains commit access to trusted repository',
    realWorldExample: 'SolarWinds (2020) - malicious code inserted into build process',
    impact: 'Backdoor shipped to 18,000+ customers including US government'
  },
  {
    vector: 'Build system compromise',
    description: 'Attacker modifies build environment to inject malicious code',
    realWorldExample: 'Codecov (2021) - bash uploader script modified in CI',
    impact: 'Credentials extracted from thousands of CI environments'
  },
  {
    vector: 'Dependency confusion',
    description: 'Malicious package published with name matching internal package',
    realWorldExample: 'Alex Birsan research (2021) - hit Apple, Microsoft, PayPal',
    impact: 'Remote code execution in internal build systems'
  },
  {
    vector: 'Typosquatting',
    description: 'Malicious package with name similar to popular package',
    realWorldExample: 'crossenv vs cross-env, thousands of similar attacks',
    impact: 'Credential theft, cryptomining, backdoors'
  },
  {
    vector: 'Compromised maintainer',
    description: 'Legitimate maintainer account compromised or goes rogue',
    realWorldExample: 'event-stream (2018) - new maintainer added cryptominer',
    impact: 'Bitcoin wallet theft from specific application'
  },
  {
    vector: 'Artifact tampering',
    description: 'Built artifacts modified after build, before deployment',
    realWorldExample: 'CCleaner (2017) - signed executable modified post-build',
    impact: '2.3 million users received backdoored software'
  }
]
```

```
Mermaid diagram: Supply chain attack surface.
Developer → Source Repository → Build System → Artifact Registry → Deployment

Attack points (labeled at each arrow):
1. Compromised credentials (Developer → Source)
2. Malicious commits (Source)
3. Dependency poisoning (Build System inputs)
4. Build environment tampering (Build System)
5. Artifact modification (Registry)
6. Deployment hijacking (Registry → Deployment)

Each stage requires different defenses.
```

### What SLSA Actually Protects Against

SLSA (Supply-chain Levels for Software Artifacts) addresses specific threats, not all of them.

| SLSA Addresses | SLSA Does NOT Address |
|----------------|----------------------|
| Unauthorized source changes | Bugs in legitimate code |
| Build tampering | Vulnerabilities in dependencies |
| Missing provenance | Social engineering |
| Non-reproducible builds | Compromised developer machines |
| Unsigned artifacts | Insider threats with legitimate access |

```typescript
// SLSA protection scope
interface SLSAProtection {
  threat: string
  protected: boolean
  mechanism: string
}

const slsaScope: SLSAProtection[] = [
  {
    threat: 'Someone modifies source after review',
    protected: true,
    mechanism: 'Provenance links artifact to specific commit'
  },
  {
    threat: 'Build system adds malicious code',
    protected: true,
    mechanism: 'Hermetic builds with verified builder'
  },
  {
    threat: 'Artifact replaced in registry',
    protected: true,
    mechanism: 'Cryptographic signatures and attestations'
  },
  {
    threat: 'Developer commits vulnerable code',
    protected: false,
    mechanism: 'SLSA doesn\'t evaluate code quality'
  },
  {
    threat: 'Malicious dependency merged intentionally',
    protected: false,
    mechanism: 'SLSA assumes source is intentional'
  }
]
```

:::warning[SLSA Is Not a Silver Bullet]
SLSA proves that an artifact came from a specific source through a specific build process. It doesn't prove the source or build process are free of vulnerabilities. You still need code review, dependency scanning, and vulnerability management.
:::

## SLSA Levels Explained

Understanding the four levels and what each requires.

### Level Requirements Overview

Each SLSA level adds requirements that provide incremental security improvements.

```typescript
// SLSA level requirements
interface SLSALevel {
  level: number
  name: string
  requirements: {
    source: string[]
    build: string[]
    provenance: string[]
  }
  effortEstimate: string
  protects: string[]
}

const slsaLevels: SLSALevel[] = [
  {
    level: 1,
    name: 'Documentation',
    requirements: {
      source: ['Version controlled'],
      build: ['Scripted build (not manual)'],
      provenance: ['Provenance exists (unsigned OK)']
    },
    effortEstimate: 'Hours - most teams already do this',
    protects: ['Accidental errors in manual builds']
  },
  {
    level: 2,
    name: 'Tamper Resistance',
    requirements: {
      source: ['Version controlled with history'],
      build: ['Hosted build service'],
      provenance: ['Authenticated provenance from build service']
    },
    effortEstimate: 'Days - mostly configuration',
    protects: ['Build system compromise by external actors']
  },
  {
    level: 3,
    name: 'Hardened Builds',
    requirements: {
      source: ['Two-person review', 'Retained history'],
      build: ['Hardened, isolated build environment'],
      provenance: ['Non-falsifiable provenance']
    },
    effortEstimate: 'Weeks - requires process changes',
    protects: ['Insider threats at build level']
  },
  {
    level: 4,
    name: 'Hermetic and Reproducible',
    requirements: {
      source: ['Two-person review', 'Verified history'],
      build: ['Hermetic builds', 'Reproducible'],
      provenance: ['Dependencies have provenance']
    },
    effortEstimate: 'Months - significant engineering investment',
    protects: ['Sophisticated supply chain attacks']
  }
]
```

```
Mermaid diagram: SLSA levels as progressive maturity.
Level 0: No provenance
    ↓
Level 1: Provenance exists
    ↓ (scripted builds, basic docs)
Level 2: Hosted builder signs provenance
    ↓ (authenticated, tamper-evident)
Level 3: Hardened builder, isolated builds
    ↓ (non-falsifiable provenance)
Level 4: Hermetic, reproducible, verified deps

Each level blocks more attack vectors.
```

### Practical Level Targets

Choosing the right level based on your threat model and resources.

```typescript
// Level selection guidance
interface LevelGuidance {
  scenario: string
  recommendedLevel: number
  rationale: string
  exceptions: string
}

const levelGuidance: LevelGuidance[] = [
  {
    scenario: 'Internal tools, low security requirements',
    recommendedLevel: 1,
    rationale: 'Provenance for debugging is valuable; threats are low',
    exceptions: 'If internal tools access production data, consider Level 2'
  },
  {
    scenario: 'Most production services',
    recommendedLevel: 2,
    rationale: 'Authenticated provenance blocks most external attacks',
    exceptions: 'High-value targets may need Level 3'
  },
  {
    scenario: 'Security-critical infrastructure',
    recommendedLevel: 3,
    rationale: 'Hardened builds protect against sophisticated attackers',
    exceptions: 'May not need Level 4 unless targeted by nation-states'
  },
  {
    scenario: 'Open source packages consumed by others',
    recommendedLevel: 3,
    rationale: 'Your security posture affects all your consumers',
    exceptions: 'Critical infrastructure packages should target Level 4'
  }
]
```

:::info[Level 2 Is the Sweet Spot for Most Teams]
Level 2 provides authenticated provenance with minimal process overhead. It blocks external attackers while keeping developer velocity high. Start here and increase only if threat model demands it.
:::

## Implementing Build Provenance

Creating attestations that link artifacts to their source and build process.

### Provenance Attestation Structure

Understanding what goes into a provenance document.

```typescript
// SLSA Provenance attestation structure (v1.0)
interface SLSAProvenance {
  _type: 'https://slsa.dev/provenance/v1'

  subject: Array<{
    name: string           // Artifact identifier
    digest: {
      sha256: string       // Cryptographic hash of artifact
    }
  }>

  predicateType: 'https://slsa.dev/provenance/v1'

  predicate: {
    // What was built
    buildDefinition: {
      buildType: string    // URI identifying build system
      externalParameters: Record<string, any>  // User-controlled inputs
      internalParameters: Record<string, any>  // System-controlled inputs
      resolvedDependencies: Array<{
        uri: string
        digest: { sha256: string }
      }>
    }

    // How it was built
    runDetails: {
      builder: {
        id: string         // URI identifying builder
        version?: string
      }
      metadata: {
        invocationId: string
        startedOn: string  // ISO 8601 timestamp
        finishedOn: string
      }
    }
  }
}

// Example provenance for a container image
const exampleProvenance: SLSAProvenance = {
  _type: 'https://slsa.dev/provenance/v1',

  subject: [{
    name: 'ghcr.io/myorg/myapp',
    digest: {
      sha256: 'abc123def456...'
    }
  }],

  predicateType: 'https://slsa.dev/provenance/v1',

  predicate: {
    buildDefinition: {
      buildType: 'https://github.com/slsa-framework/slsa-github-generator/container@v1',
      externalParameters: {
        repository: 'https://github.com/myorg/myapp',
        ref: 'refs/heads/main',
        commit: 'a1b2c3d4e5f6...'
      },
      internalParameters: {},
      resolvedDependencies: [
        {
          uri: 'git+https://github.com/myorg/myapp@refs/heads/main',
          digest: { sha256: 'a1b2c3d4e5f6...' }
        }
      ]
    },
    runDetails: {
      builder: {
        id: 'https://github.com/slsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@refs/tags/v1.9.0'
      },
      metadata: {
        invocationId: 'https://github.com/myorg/myapp/actions/runs/123456789',
        startedOn: '2024-01-15T10:30:00Z',
        finishedOn: '2024-01-15T10:35:00Z'
      }
    }
  }
}
```

### GitHub Actions SLSA Generator

Using the official GitHub generator for SLSA Level 3 provenance.

```yaml
# .github/workflows/release.yml
name: Release with SLSA Provenance

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write       # For creating releases
  id-token: write       # For OIDC token (keyless signing)
  packages: write       # For container registry
  attestations: write   # For provenance attestations

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      digest: ${{ steps.build.outputs.digest }}
      image: ${{ steps.build.outputs.image }}

    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ghcr.io/${{ github.repository }}:${{ github.ref_name }}

      - name: Output image digest
        run: |
          echo "digest=${{ steps.build.outputs.digest }}" >> $GITHUB_OUTPUT
          echo "image=ghcr.io/${{ github.repository }}" >> $GITHUB_OUTPUT

  # Generate SLSA provenance using official generator
  provenance:
    needs: build
    permissions:
      actions: read
      id-token: write
      packages: write

    uses: slsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@v1.9.0
    with:
      image: ${{ needs.build.outputs.image }}
      digest: ${{ needs.build.outputs.digest }}
      registry-username: ${{ github.actor }}
    secrets:
      registry-password: ${{ secrets.GITHUB_TOKEN }}
```

```typescript
// Verifying SLSA provenance with slsa-verifier
const verificationCommands = {
  // Install verifier
  install: 'go install github.com/slsa-framework/slsa-verifier/v2/cli/slsa-verifier@latest',

  // Verify container image
  verifyContainer: `
    slsa-verifier verify-image ghcr.io/myorg/myapp:v1.0.0 \\
      --source-uri github.com/myorg/myapp \\
      --source-tag v1.0.0
  `,

  // Verify with specific builder
  verifyWithBuilder: `
    slsa-verifier verify-image ghcr.io/myorg/myapp:v1.0.0 \\
      --source-uri github.com/myorg/myapp \\
      --builder-id https://github.com/slsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@refs/tags/v1.9.0
  `,

  // Verify artifact (non-container)
  verifyArtifact: `
    slsa-verifier verify-artifact myapp-v1.0.0.tar.gz \\
      --provenance-path myapp-v1.0.0.tar.gz.intoto.jsonl \\
      --source-uri github.com/myorg/myapp \\
      --source-tag v1.0.0
  `
}
```

### Provenance for Non-Container Artifacts

Generating provenance for binaries, packages, and other artifact types.

```yaml
# .github/workflows/release-binary.yml
name: Release Go Binary with Provenance

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write
  id-token: write

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      hashes: ${{ steps.hash.outputs.hashes }}

    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Build binaries
        run: |
          GOOS=linux GOARCH=amd64 go build -o myapp-linux-amd64 .
          GOOS=darwin GOARCH=amd64 go build -o myapp-darwin-amd64 .
          GOOS=windows GOARCH=amd64 go build -o myapp-windows-amd64.exe .

      - name: Generate hashes
        id: hash
        run: |
          echo "hashes=$(sha256sum myapp-* | base64 -w0)" >> $GITHUB_OUTPUT

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: binaries
          path: myapp-*

  provenance:
    needs: build
    permissions:
      actions: read
      id-token: write
      contents: write

    uses: slsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@v1.9.0
    with:
      base64-subjects: ${{ needs.build.outputs.hashes }}
      upload-assets: true  # Upload to release

  release:
    needs: [build, provenance]
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: binaries

      - name: Create release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            myapp-*
```

## Artifact Signing Strategies

Different approaches to signing artifacts and when to use each.

### Signing Methods Comparison

Choosing the right signing approach for your use case.

```typescript
// Signing method comparison
interface SigningMethod {
  name: string
  mechanism: string
  keyManagement: string
  verification: string
  pros: string[]
  cons: string[]
  bestFor: string
}

const signingMethods: SigningMethod[] = [
  {
    name: 'Long-lived keys (GPG/PGP)',
    mechanism: 'Asymmetric encryption with persistent keypair',
    keyManagement: 'Manual key generation, distribution, rotation',
    verification: 'Requires public key distribution (keyserver, repo)',
    pros: [
      'Well-understood, mature tooling',
      'Works offline',
      'No external dependencies'
    ],
    cons: [
      'Key rotation is painful',
      'Key compromise affects all past signatures',
      'TOFU trust model problems'
    ],
    bestFor: 'Small teams, air-gapped environments'
  },
  {
    name: 'Keyless signing (Sigstore/Cosign)',
    mechanism: 'Short-lived certificates from OIDC identity',
    keyManagement: 'No keys to manage—identity-based',
    verification: 'Transparency log lookup (Rekor)',
    pros: [
      'No key management burden',
      'Identity-tied signatures',
      'Transparency log for audit'
    ],
    cons: [
      'Requires internet connectivity',
      'Depends on Sigstore infrastructure',
      'Newer, less mature ecosystem'
    ],
    bestFor: 'CI/CD pipelines, container images'
  },
  {
    name: 'KMS-backed signing',
    mechanism: 'Keys stored in cloud HSM/KMS',
    keyManagement: 'Cloud provider handles key protection',
    verification: 'Public key exported from KMS',
    pros: [
      'Hardware-protected keys',
      'Audit logging built-in',
      'IAM integration'
    ],
    cons: [
      'Cloud vendor lock-in',
      'Cost for high-volume signing',
      'Requires cloud connectivity'
    ],
    bestFor: 'Enterprise, compliance requirements'
  }
]
```

| Method | Key Management | Verification Complexity | CI/CD Fit | Compliance |
|--------|---------------|------------------------|-----------|------------|
| GPG | High (manual) | Medium (keyservers) | Poor | Medium |
| Sigstore/Cosign | None (keyless) | Low (automatic) | Excellent | Good |
| KMS-backed | Low (managed) | Low (exported key) | Good | Excellent |

### Keyless Signing with Cosign

Implementing identity-based signing without managing keys.

```yaml
# .github/workflows/sign-container.yml
name: Build, Sign, and Attest Container

on:
  push:
    branches: [main]
    tags: ['v*']

permissions:
  contents: read
  packages: write
  id-token: write  # Required for OIDC token

jobs:
  build-sign:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ghcr.io/${{ github.repository }}:${{ github.sha }}

      # Keyless signing - no keys to manage!
      - name: Sign container image
        env:
          DIGEST: ${{ steps.build.outputs.digest }}
        run: |
          cosign sign --yes ghcr.io/${{ github.repository }}@${DIGEST}

      # Attach SBOM attestation
      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: ghcr.io/${{ github.repository }}@${{ steps.build.outputs.digest }}
          output-file: sbom.spdx.json
          format: spdx-json

      - name: Attest SBOM
        run: |
          cosign attest --yes \
            --predicate sbom.spdx.json \
            --type spdxjson \
            ghcr.io/${{ github.repository }}@${{ steps.build.outputs.digest }}
```

```typescript
// Verifying keyless signatures
const cosignVerification = {
  // Verify by identity (keyless)
  verifyByIdentity: `
    cosign verify ghcr.io/myorg/myapp:latest \\
      --certificate-identity "https://github.com/myorg/myapp/.github/workflows/release.yml@refs/heads/main" \\
      --certificate-oidc-issuer "https://token.actions.githubusercontent.com"
  `,

  // Verify with identity regex (for tag-based releases)
  verifyByPattern: `
    cosign verify ghcr.io/myorg/myapp:v1.0.0 \\
      --certificate-identity-regexp "https://github.com/myorg/myapp/.github/workflows/release.yml@refs/tags/v.*" \\
      --certificate-oidc-issuer "https://token.actions.githubusercontent.com"
  `,

  // Verify attestation
  verifyAttestation: `
    cosign verify-attestation ghcr.io/myorg/myapp:latest \\
      --type spdxjson \\
      --certificate-identity "https://github.com/myorg/myapp/.github/workflows/release.yml@refs/heads/main" \\
      --certificate-oidc-issuer "https://token.actions.githubusercontent.com"
  `
}
```

### KMS-Backed Signing

Using cloud key management for regulated environments.

```typescript
// AWS KMS signing setup
interface KMSSigningSetup {
  keyCreation: string
  cosignUsage: string
  verification: string
}

const awsKMSSetup: KMSSigningSetup = {
  keyCreation: `
    # Create asymmetric signing key
    aws kms create-key \\
      --key-usage SIGN_VERIFY \\
      --key-spec ECC_NIST_P256 \\
      --description "Container image signing key"

    # Create alias for easier reference
    aws kms create-alias \\
      --alias-name alias/container-signing \\
      --target-key-id <key-id>
  `,

  cosignUsage: `
    # Sign with KMS key
    cosign sign --key awskms:///alias/container-signing \\
      ghcr.io/myorg/myapp@sha256:abc123...

    # Export public key for verification
    cosign public-key --key awskms:///alias/container-signing > cosign.pub
  `,

  verification: `
    # Verify with exported public key
    cosign verify --key cosign.pub \\
      ghcr.io/myorg/myapp@sha256:abc123...
  `
}
```

```yaml
# .github/workflows/sign-with-kms.yml
name: Sign with AWS KMS

on:
  push:
    tags: ['v*']

permissions:
  id-token: write  # For AWS OIDC
  packages: write

jobs:
  sign:
    runs-on: ubuntu-latest

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::123456789012:role/github-signing-role
          aws-region: us-east-1

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Sign image with KMS
        run: |
          cosign sign --key awskms:///alias/container-signing \
            ghcr.io/${{ github.repository }}@${{ env.DIGEST }}
```

:::info[Keyless vs KMS: When to Choose Each]
Use keyless signing for most open source and internal projects—it's simpler and doesn't require key management. Use KMS-backed signing when compliance requires hardware key protection, audit trails, or you need to sign in air-gapped environments.
:::

## Verification at Deployment Time

Enforcing signature and provenance requirements before code runs.

### Kubernetes Admission Control

Using policy engines to enforce signing requirements.

```yaml
# Sigstore Policy Controller installation
# helm repo add sigstore https://sigstore.github.io/helm-charts
# helm install policy-controller sigstore/policy-controller

# ClusterImagePolicy for container verification
apiVersion: policy.sigstore.dev/v1beta1
kind: ClusterImagePolicy
metadata:
  name: require-signed-images
spec:
  images:
    # Match all images from our registry
    - glob: "ghcr.io/myorg/**"

  authorities:
    # Keyless verification (recommended)
    - keyless:
        url: https://fulcio.sigstore.dev
        identities:
          - issuer: https://token.actions.githubusercontent.com
            subjectRegExp: https://github.com/myorg/.*/.*/.github/workflows/.*@refs/tags/v.*
      ctlog:
        url: https://rekor.sigstore.dev

    # Or key-based verification
    # - key:
    #     data: |
    #       -----BEGIN PUBLIC KEY-----
    #       ...
    #       -----END PUBLIC KEY-----
```

```yaml
# Namespace-level enforcement
apiVersion: v1
kind: Namespace
metadata:
  name: production
  labels:
    # Enforce policy on this namespace
    policy.sigstore.dev/include: "true"
```

```typescript
// What happens when verification fails
const verificationBehavior = {
  validImage: {
    action: 'Allowed',
    log: 'Image ghcr.io/myorg/app:v1.0.0 verified against policy'
  },

  unsignedImage: {
    action: 'Denied',
    error: 'admission webhook denied: no matching signatures found',
    mitigation: 'Sign the image or add exception to policy'
  },

  wrongIdentity: {
    action: 'Denied',
    error: 'admission webhook denied: signature identity does not match policy',
    mitigation: 'Check workflow path and OIDC issuer in policy'
  }
}
```

### Terraform and Infrastructure Verification

Verifying artifacts before infrastructure deployment.

```hcl
# terraform/main.tf
# Verify container signature before using image

data "external" "verify_image" {
  program = ["bash", "-c", <<-EOF
    cosign verify \
      --certificate-identity-regexp "https://github.com/myorg/.*" \
      --certificate-oidc-issuer "https://token.actions.githubusercontent.com" \
      ${var.container_image} 2>&1 && \
    echo '{"verified": "true"}' || \
    echo '{"verified": "false", "error": "Signature verification failed"}'
  EOF
  ]
}

resource "null_resource" "verify_signature" {
  # Fail if verification failed
  count = data.external.verify_image.result.verified == "true" ? 0 : 1

  provisioner "local-exec" {
    command = "echo 'ERROR: Image signature verification failed' && exit 1"
  }
}

# Only proceed if verification passed
resource "kubernetes_deployment" "app" {
  depends_on = [null_resource.verify_signature]

  metadata {
    name = "myapp"
  }

  spec {
    template {
      spec {
        container {
          image = var.container_image
        }
      }
    }
  }
}
```

### CI/CD Pipeline Verification Gates

Adding verification steps to deployment pipelines.

```yaml
# .github/workflows/deploy.yml
name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag to deploy'
        required: true

jobs:
  verify:
    runs-on: ubuntu-latest
    outputs:
      verified: ${{ steps.verify.outputs.verified }}

    steps:
      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Verify image signature
        id: verify
        run: |
          IMAGE="ghcr.io/${{ github.repository }}:${{ inputs.image_tag }}"

          if cosign verify \
            --certificate-identity-regexp "https://github.com/${{ github.repository }}/.github/workflows/release.yml@refs/tags/.*" \
            --certificate-oidc-issuer "https://token.actions.githubusercontent.com" \
            "${IMAGE}"; then
            echo "verified=true" >> $GITHUB_OUTPUT
          else
            echo "verified=false" >> $GITHUB_OUTPUT
            echo "::error::Image signature verification failed"
            exit 1
          fi

      - name: Verify SLSA provenance
        run: |
          slsa-verifier verify-image "ghcr.io/${{ github.repository }}:${{ inputs.image_tag }}" \
            --source-uri "github.com/${{ github.repository }}" \
            --source-tag "${{ inputs.image_tag }}"

  deploy:
    needs: verify
    if: needs.verify.outputs.verified == 'true'
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Deploy to Kubernetes
        run: |
          kubectl set image deployment/myapp \
            myapp=ghcr.io/${{ github.repository }}:${{ inputs.image_tag }}
```

## SBOM Integration

Combining Software Bill of Materials with provenance for complete visibility.

### Generating SBOMs

Creating comprehensive dependency lists during builds.

```yaml
# .github/workflows/sbom.yml
name: Build with SBOM

on:
  push:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Build container
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ghcr.io/${{ github.repository }}:${{ github.sha }}

      # Generate SBOM using Syft
      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: ghcr.io/${{ github.repository }}@${{ steps.build.outputs.digest }}
          format: spdx-json
          output-file: sbom.spdx.json

      # Alternative: CycloneDX format
      - name: Generate CycloneDX SBOM
        run: |
          syft ghcr.io/${{ github.repository }}@${{ steps.build.outputs.digest }} \
            -o cyclonedx-json=sbom.cyclonedx.json

      # Attest SBOM to the image
      - name: Attest SBOM
        run: |
          cosign attest --yes \
            --predicate sbom.spdx.json \
            --type spdxjson \
            ghcr.io/${{ github.repository }}@${{ steps.build.outputs.digest }}

      # Also scan for vulnerabilities
      - name: Scan for vulnerabilities
        uses: anchore/scan-action@v3
        with:
          image: ghcr.io/${{ github.repository }}@${{ steps.build.outputs.digest }}
          fail-build: false
          severity-cutoff: critical
```

```typescript
// SBOM structure overview (SPDX)
interface SPDXSBOM {
  spdxVersion: 'SPDX-2.3'
  dataLicense: 'CC0-1.0'
  SPDXID: 'SPDXRef-DOCUMENT'
  name: string
  documentNamespace: string

  packages: Array<{
    SPDXID: string
    name: string
    versionInfo: string
    downloadLocation: string
    filesAnalyzed: boolean
    licenseConcluded: string
    licenseDeclared: string
    externalRefs?: Array<{
      referenceCategory: 'PACKAGE-MANAGER' | 'SECURITY'
      referenceType: string
      referenceLocator: string  // e.g., purl
    }>
  }>

  relationships: Array<{
    spdxElementId: string
    relatedSpdxElement: string
    relationshipType: 'DEPENDS_ON' | 'CONTAINS' | 'BUILD_TOOL_OF'
  }>
}
```

### Querying SBOM Attestations

Extracting and analyzing SBOM data from signed images.

```typescript
// Retrieve and query SBOM attestations
const sbomQueries = {
  // Download SBOM attestation
  downloadSBOM: `
    cosign download attestation ghcr.io/myorg/myapp:v1.0.0 \\
      --predicate-type spdxjson | jq -r '.payload' | base64 -d > sbom.json
  `,

  // List all packages in SBOM
  listPackages: `
    cat sbom.json | jq '.packages[] | {name: .name, version: .versionInfo}'
  `,

  // Find specific dependency
  findDependency: `
    cat sbom.json | jq '.packages[] | select(.name | contains("lodash"))'
  `,

  // Extract all package URLs (purls) for vulnerability scanning
  extractPurls: `
    cat sbom.json | jq -r '.packages[].externalRefs[] |
      select(.referenceType == "purl") | .referenceLocator'
  `,

  // Check for specific vulnerable version
  checkVulnVersion: `
    cat sbom.json | jq '.packages[] |
      select(.name == "log4j-core" and .versionInfo | startswith("2.14"))'
  `
}
```

```
Mermaid diagram: SBOM and provenance relationship.
Source Code
    ↓ (build)
Build Process
    ├── Creates: Container Image (artifact)
    ├── Generates: SBOM (what's inside)
    └── Generates: Provenance (how it was built)

All three are signed and linked:
- Image digest appears in provenance subject
- Image digest appears in SBOM document
- Provenance and SBOM attached as attestations
```

## Practical Implementation Checklist

Step-by-step guide to implementing a baseline supply chain security posture.

### Phase 1: Foundation (Week 1-2)

Basic instrumentation and visibility.

```typescript
// Phase 1 checklist
const phase1Checklist = [
  {
    task: 'Inventory current artifacts',
    actions: [
      'List all container images published',
      'List all binaries/packages released',
      'Identify artifact registries in use'
    ],
    output: 'Artifact inventory spreadsheet'
  },
  {
    task: 'Add basic provenance',
    actions: [
      'Add build metadata to artifact labels/tags',
      'Include git SHA in image tags',
      'Add build timestamp to artifacts'
    ],
    output: 'All artifacts traceable to commits'
  },
  {
    task: 'Document current build process',
    actions: [
      'Document build scripts and configurations',
      'Identify build system (GitHub Actions, Jenkins, etc.)',
      'Map build dependencies'
    ],
    output: 'Build process documentation'
  }
]
```

### Phase 2: Signing (Week 3-4)

Implementing artifact signing.

```yaml
# Phase 2: Add signing to existing workflow
# Add these steps to your existing build workflow

- name: Install Cosign
  uses: sigstore/cosign-installer@v3

- name: Sign container image
  env:
    DIGEST: ${{ steps.build.outputs.digest }}
  run: |
    cosign sign --yes ghcr.io/${{ github.repository }}@${DIGEST}

    # Verify our own signature immediately
    cosign verify \
      --certificate-identity "${{ github.server_url }}/${{ github.repository }}/.github/workflows/${{ github.workflow }}.yml@${{ github.ref }}" \
      --certificate-oidc-issuer "https://token.actions.githubusercontent.com" \
      ghcr.io/${{ github.repository }}@${DIGEST}
```

### Phase 3: Verification (Week 5-6)

Enforcing signatures in deployment.

```typescript
// Phase 3 checklist
const phase3Checklist = [
  {
    task: 'Add verification to staging deployment',
    actions: [
      'Add cosign verify step before deployment',
      'Configure policy to warn (not block) on failure',
      'Monitor verification success rate'
    ],
    output: 'Staging deployments verify signatures'
  },
  {
    task: 'Implement admission control (Kubernetes)',
    actions: [
      'Deploy Sigstore Policy Controller',
      'Create ClusterImagePolicy for your images',
      'Test with non-production namespace first'
    ],
    output: 'Kubernetes enforces signatures'
  },
  {
    task: 'Add verification to CI promotion',
    actions: [
      'Require verification before promoting to production',
      'Add SLSA verifier to deployment workflow',
      'Block promotion if verification fails'
    ],
    output: 'Production deployments require valid signatures'
  }
]
```

### Phase 4: Hardening (Ongoing)

Continuous improvement toward higher SLSA levels.

```typescript
// Phase 4: Progressive hardening
const hardeningRoadmap = [
  {
    milestone: 'SLSA Level 2 complete',
    requirements: [
      'All artifacts signed',
      'Provenance generated by build service',
      'Verification enforced in production'
    ],
    estimatedTimeline: '6-8 weeks from start'
  },
  {
    milestone: 'SBOM integration',
    requirements: [
      'SBOM generated for all containers',
      'SBOM attested alongside images',
      'Vulnerability scanning using SBOM'
    ],
    estimatedTimeline: '10-12 weeks from start'
  },
  {
    milestone: 'SLSA Level 3 (optional)',
    requirements: [
      'Two-person review for all changes',
      'Isolated build environment',
      'Non-falsifiable provenance'
    ],
    estimatedTimeline: '16-20 weeks from start'
  }
]
```

:::success[Start Small, Verify Often]
Don't try to implement everything at once. Start with signing one artifact type, verify it works, then expand. Each phase should be fully working before moving to the next.
:::

## Troubleshooting Common Issues

Problems you'll encounter and how to solve them.

```typescript
// Common issues and solutions
interface TroubleshootingGuide {
  issue: string
  symptoms: string[]
  cause: string
  solution: string
}

const troubleshootingGuide: TroubleshootingGuide[] = [
  {
    issue: 'Signature verification fails with "no matching signatures"',
    symptoms: [
      'cosign verify returns error',
      'Admission webhook denies pods',
      'Deployment blocked'
    ],
    cause: 'Image was signed but identity doesn\'t match verification policy',
    solution: `
      1. Check the signing identity: cosign verify --output text <image>
      2. Compare with expected identity in policy
      3. Common issues:
         - Branch vs tag reference mismatch (refs/heads vs refs/tags)
         - Workflow file path changed
         - Different OIDC issuer than expected
    `
  },
  {
    issue: 'OIDC token not available in GitHub Actions',
    symptoms: [
      'Error: unable to get OIDC token',
      'Keyless signing fails'
    ],
    cause: 'Missing id-token: write permission',
    solution: `
      Add to workflow:
      permissions:
        id-token: write
        contents: read
    `
  },
  {
    issue: 'Provenance attestation not found',
    symptoms: [
      'slsa-verifier fails',
      'Attestation download returns empty'
    ],
    cause: 'Provenance workflow didn\'t run or failed',
    solution: `
      1. Check GitHub Actions run for provenance job
      2. Verify slsa-github-generator version is correct
      3. Check permissions on provenance workflow
      4. Ensure artifact digest is passed correctly
    `
  },
  {
    issue: 'SBOM generation takes too long',
    symptoms: [
      'Build times increased significantly',
      'SBOM action times out'
    ],
    cause: 'Large image with many layers',
    solution: `
      1. Use multi-stage builds to reduce final image size
      2. Run SBOM generation in parallel job
      3. Consider generating SBOM from lockfiles instead of image
    `
  }
]
```

## Conclusion

Supply chain security is a spectrum, not a binary. Perfect security is impossible, but a practical baseline is achievable. Start with SLSA Level 2 as your target—it provides authenticated provenance that blocks most external attackers without requiring significant process changes. Use keyless signing with Cosign for simplicity; it eliminates key management while providing strong identity binding through OIDC. Add verification at deployment time using Kubernetes admission control or CI/CD gates to ensure only signed artifacts reach production. Layer in SBOMs for vulnerability visibility once signing is established. The implementation path is: inventory your artifacts, add signing to builds, enforce verification in staging, then production, and continuously harden. Each step provides incremental security improvement. Don't let perfect be the enemy of good—a signed artifact with basic provenance is infinitely more secure than an unsigned one.

---

## Cover Image Prompts

### Prompt 1: Chain Links with Digital Overlay
Close-up photograph of heavy industrial chain links with a digital holographic overlay showing code signatures and checksums. Blue-green digital glow on metallic surfaces. Dark background with dramatic lighting. The fusion of physical security metaphor with digital verification.

### Prompt 2: Wax Seal on Digital Document
Artistic render of a traditional red wax seal stamped on a digital document or code file. The seal shows cryptographic symbols instead of traditional heraldry. Blend of antique and modern aesthetics. Parchment texture transitioning to pixel grid.

### Prompt 3: Factory Assembly Line with QR Codes
Photograph of a modern manufacturing assembly line where each product has a visible QR code or digital tag being scanned. Clean, well-lit industrial environment. The concept of provenance and tracking through production.

### Prompt 4: Fingerprint on Circuit Board
Macro photograph of a human fingerprint pattern overlaid on or etched into a circuit board surface. Green PCB with copper traces. The fingerprint as metaphor for unique identity and verification.

### Prompt 5: Notary Stamp and Keyboard
Photograph of a traditional notary public embosser/stamp next to a modern keyboard or laptop. Documents with both physical embossed seals and printed cryptographic hashes. The evolution of attestation from physical to digital.
