---
slug: "docker"
displayName: "Docker"
description: "Container images, multi-stage builds, and runtime tooling for packaging applications with reproducible dependencies across development, CI, and production environments."
cover: "./cover.jpg"
coverAlt: "Stacked shipping containers arranged into an organized modular grid pattern"
featured: false
logo: "./docker.svg"
isSkill: true
---

Docker changed how platform engineers think about deployment artifacts. Instead of configuring servers to match application requirements, teams package applications with their exact dependencies into images that run identically everywhere. Multi-stage builds keep production images lean, BuildKit caching speeds up CI pipelines, and OCI-compliant registries give organizations a standard way to store and distribute artifacts across environments.

For platform engineering, Docker sits at the foundation layer. Golden-path Dockerfiles enforce security baselines&mdash;non-root users, minimal base images, pinned package versions&mdash;before code ever reaches a cluster. Build pipelines scan images for CVEs, sign them with cosign or Notary, and push to private registries with promotion policies that gate what reaches production. The container image becomes the unit of trust between development teams and the platform.

Docker's role has shifted as Kubernetes handles orchestration and containerd runs workloads directly. The Docker CLI and Compose remain essential for local development, letting engineers run multi-service stacks on their laptops with a single command. Understanding image layering, build context optimization, and runtime security constraints still matters daily&mdash;even in environments where Docker Engine itself never touches a production node.
